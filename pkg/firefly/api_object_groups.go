/*
 * Firefly III API v1.5.2
 *
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2021-05-14T15:49:56+00:00 
 *
 * API version: 1.5.2
 * Contact: james@firefly-iii.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package firefly

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type ObjectGroupsApi interface {

	/*
	 * DeleteObjectGroup Delete a object group.
	 * Delete a object group.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the object group.
	 * @return ApiDeleteObjectGroupRequest
	 */
	DeleteObjectGroup(ctx _context.Context, id int32) ApiDeleteObjectGroupRequest

	/*
	 * DeleteObjectGroupExecute executes the request
	 */
	DeleteObjectGroupExecute(r ApiDeleteObjectGroupRequest) (*_nethttp.Response, error)

	/*
	 * GetObjectGroup Get a single object group.
	 * Get a single object group.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the object group.
	 * @return ApiGetObjectGroupRequest
	 */
	GetObjectGroup(ctx _context.Context, id int32) ApiGetObjectGroupRequest

	/*
	 * GetObjectGroupExecute executes the request
	 * @return ObjectGroupSingle
	 */
	GetObjectGroupExecute(r ApiGetObjectGroupRequest) (ObjectGroupSingle, *_nethttp.Response, error)

	/*
	 * ListBillByObjectGroup List all bills with this object group.
	 * List all bills with this object group.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the account.
	 * @return ApiListBillByObjectGroupRequest
	 */
	ListBillByObjectGroup(ctx _context.Context, id int32) ApiListBillByObjectGroupRequest

	/*
	 * ListBillByObjectGroupExecute executes the request
	 * @return BillArray
	 */
	ListBillByObjectGroupExecute(r ApiListBillByObjectGroupRequest) (BillArray, *_nethttp.Response, error)

	/*
	 * ListObjectGroups List all oject groups.
	 * List all oject groups.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiListObjectGroupsRequest
	 */
	ListObjectGroups(ctx _context.Context) ApiListObjectGroupsRequest

	/*
	 * ListObjectGroupsExecute executes the request
	 * @return ObjectGroupArray
	 */
	ListObjectGroupsExecute(r ApiListObjectGroupsRequest) (ObjectGroupArray, *_nethttp.Response, error)

	/*
	 * ListPiggyBankByObjectGroup List all piggy banks related to the object group.
	 * This endpoint returns a list of all the piggy banks connected to the object group.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the account.
	 * @return ApiListPiggyBankByObjectGroupRequest
	 */
	ListPiggyBankByObjectGroup(ctx _context.Context, id int32) ApiListPiggyBankByObjectGroupRequest

	/*
	 * ListPiggyBankByObjectGroupExecute executes the request
	 * @return PiggyBankArray
	 */
	ListPiggyBankByObjectGroupExecute(r ApiListPiggyBankByObjectGroupRequest) (PiggyBankArray, *_nethttp.Response, error)

	/*
	 * UpdateObjectGroup Update existing object group.
	 * Update existing object group.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the object group
	 * @return ApiUpdateObjectGroupRequest
	 */
	UpdateObjectGroup(ctx _context.Context, id int32) ApiUpdateObjectGroupRequest

	/*
	 * UpdateObjectGroupExecute executes the request
	 * @return ObjectGroupSingle
	 */
	UpdateObjectGroupExecute(r ApiUpdateObjectGroupRequest) (ObjectGroupSingle, *_nethttp.Response, error)
}

// ObjectGroupsApiService ObjectGroupsApi service
type ObjectGroupsApiService service

type ApiDeleteObjectGroupRequest struct {
	ctx _context.Context
	ApiService ObjectGroupsApi
	id int32
}


func (r ApiDeleteObjectGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteObjectGroupExecute(r)
}

/*
 * DeleteObjectGroup Delete a object group.
 * Delete a object group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the object group.
 * @return ApiDeleteObjectGroupRequest
 */
func (a *ObjectGroupsApiService) DeleteObjectGroup(ctx _context.Context, id int32) ApiDeleteObjectGroupRequest {
	return ApiDeleteObjectGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ObjectGroupsApiService) DeleteObjectGroupExecute(r ApiDeleteObjectGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectGroupsApiService.DeleteObjectGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/object_groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetObjectGroupRequest struct {
	ctx _context.Context
	ApiService ObjectGroupsApi
	id int32
}


func (r ApiGetObjectGroupRequest) Execute() (ObjectGroupSingle, *_nethttp.Response, error) {
	return r.ApiService.GetObjectGroupExecute(r)
}

/*
 * GetObjectGroup Get a single object group.
 * Get a single object group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the object group.
 * @return ApiGetObjectGroupRequest
 */
func (a *ObjectGroupsApiService) GetObjectGroup(ctx _context.Context, id int32) ApiGetObjectGroupRequest {
	return ApiGetObjectGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ObjectGroupSingle
 */
func (a *ObjectGroupsApiService) GetObjectGroupExecute(r ApiGetObjectGroupRequest) (ObjectGroupSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ObjectGroupSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectGroupsApiService.GetObjectGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/object_groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillByObjectGroupRequest struct {
	ctx _context.Context
	ApiService ObjectGroupsApi
	id int32
	page *int32
}

func (r ApiListBillByObjectGroupRequest) Page(page int32) ApiListBillByObjectGroupRequest {
	r.page = &page
	return r
}

func (r ApiListBillByObjectGroupRequest) Execute() (BillArray, *_nethttp.Response, error) {
	return r.ApiService.ListBillByObjectGroupExecute(r)
}

/*
 * ListBillByObjectGroup List all bills with this object group.
 * List all bills with this object group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the account.
 * @return ApiListBillByObjectGroupRequest
 */
func (a *ObjectGroupsApiService) ListBillByObjectGroup(ctx _context.Context, id int32) ApiListBillByObjectGroupRequest {
	return ApiListBillByObjectGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BillArray
 */
func (a *ObjectGroupsApiService) ListBillByObjectGroupExecute(r ApiListBillByObjectGroupRequest) (BillArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BillArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectGroupsApiService.ListBillByObjectGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/object_groups/{id}/bills"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListObjectGroupsRequest struct {
	ctx _context.Context
	ApiService ObjectGroupsApi
	page *int32
}

func (r ApiListObjectGroupsRequest) Page(page int32) ApiListObjectGroupsRequest {
	r.page = &page
	return r
}

func (r ApiListObjectGroupsRequest) Execute() (ObjectGroupArray, *_nethttp.Response, error) {
	return r.ApiService.ListObjectGroupsExecute(r)
}

/*
 * ListObjectGroups List all oject groups.
 * List all oject groups.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListObjectGroupsRequest
 */
func (a *ObjectGroupsApiService) ListObjectGroups(ctx _context.Context) ApiListObjectGroupsRequest {
	return ApiListObjectGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ObjectGroupArray
 */
func (a *ObjectGroupsApiService) ListObjectGroupsExecute(r ApiListObjectGroupsRequest) (ObjectGroupArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ObjectGroupArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectGroupsApiService.ListObjectGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/object_groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPiggyBankByObjectGroupRequest struct {
	ctx _context.Context
	ApiService ObjectGroupsApi
	id int32
	page *int32
}

func (r ApiListPiggyBankByObjectGroupRequest) Page(page int32) ApiListPiggyBankByObjectGroupRequest {
	r.page = &page
	return r
}

func (r ApiListPiggyBankByObjectGroupRequest) Execute() (PiggyBankArray, *_nethttp.Response, error) {
	return r.ApiService.ListPiggyBankByObjectGroupExecute(r)
}

/*
 * ListPiggyBankByObjectGroup List all piggy banks related to the object group.
 * This endpoint returns a list of all the piggy banks connected to the object group.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the account.
 * @return ApiListPiggyBankByObjectGroupRequest
 */
func (a *ObjectGroupsApiService) ListPiggyBankByObjectGroup(ctx _context.Context, id int32) ApiListPiggyBankByObjectGroupRequest {
	return ApiListPiggyBankByObjectGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return PiggyBankArray
 */
func (a *ObjectGroupsApiService) ListPiggyBankByObjectGroupExecute(r ApiListPiggyBankByObjectGroupRequest) (PiggyBankArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PiggyBankArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectGroupsApiService.ListPiggyBankByObjectGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/object_groups/{id}/piggy_banks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateObjectGroupRequest struct {
	ctx _context.Context
	ApiService ObjectGroupsApi
	id int32
	objectGroupUpdate *ObjectGroupUpdate
}

func (r ApiUpdateObjectGroupRequest) ObjectGroupUpdate(objectGroupUpdate ObjectGroupUpdate) ApiUpdateObjectGroupRequest {
	r.objectGroupUpdate = &objectGroupUpdate
	return r
}

func (r ApiUpdateObjectGroupRequest) Execute() (ObjectGroupSingle, *_nethttp.Response, error) {
	return r.ApiService.UpdateObjectGroupExecute(r)
}

/*
 * UpdateObjectGroup Update existing object group.
 * Update existing object group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the object group
 * @return ApiUpdateObjectGroupRequest
 */
func (a *ObjectGroupsApiService) UpdateObjectGroup(ctx _context.Context, id int32) ApiUpdateObjectGroupRequest {
	return ApiUpdateObjectGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ObjectGroupSingle
 */
func (a *ObjectGroupsApiService) UpdateObjectGroupExecute(r ApiUpdateObjectGroupRequest) (ObjectGroupSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ObjectGroupSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectGroupsApiService.UpdateObjectGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/object_groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.objectGroupUpdate == nil {
		return localVarReturnValue, nil, reportError("objectGroupUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectGroupUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
