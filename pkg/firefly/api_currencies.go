/*
 * Firefly III API v1.5.2
 *
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2021-05-14T15:49:56+00:00 
 *
 * API version: 1.5.2
 * Contact: james@firefly-iii.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package firefly

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type CurrenciesApi interface {

	/*
	 * DefaultCurrency Make currency default currency.
	 * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiDefaultCurrencyRequest
	 */
	DefaultCurrency(ctx _context.Context, code string) ApiDefaultCurrencyRequest

	/*
	 * DefaultCurrencyExecute executes the request
	 * @return CurrencySingle
	 */
	DefaultCurrencyExecute(r ApiDefaultCurrencyRequest) (CurrencySingle, *_nethttp.Response, error)

	/*
	 * DeleteCurrency Delete a currency.
	 * Delete a currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiDeleteCurrencyRequest
	 */
	DeleteCurrency(ctx _context.Context, code string) ApiDeleteCurrencyRequest

	/*
	 * DeleteCurrencyExecute executes the request
	 */
	DeleteCurrencyExecute(r ApiDeleteCurrencyRequest) (*_nethttp.Response, error)

	/*
	 * DisableCurrency Disable a currency.
	 * Disable a currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiDisableCurrencyRequest
	 */
	DisableCurrency(ctx _context.Context, code int32) ApiDisableCurrencyRequest

	/*
	 * DisableCurrencyExecute executes the request
	 * @return CurrencySingle
	 */
	DisableCurrencyExecute(r ApiDisableCurrencyRequest) (CurrencySingle, *_nethttp.Response, error)

	/*
	 * EnableCurrency Enable a single currency.
	 * Enable a single currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiEnableCurrencyRequest
	 */
	EnableCurrency(ctx _context.Context, code string) ApiEnableCurrencyRequest

	/*
	 * EnableCurrencyExecute executes the request
	 * @return CurrencySingle
	 */
	EnableCurrencyExecute(r ApiEnableCurrencyRequest) (CurrencySingle, *_nethttp.Response, error)

	/*
	 * GetCurrency Get a single currency.
	 * Get a single currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiGetCurrencyRequest
	 */
	GetCurrency(ctx _context.Context, code string) ApiGetCurrencyRequest

	/*
	 * GetCurrencyExecute executes the request
	 * @return CurrencySingle
	 */
	GetCurrencyExecute(r ApiGetCurrencyRequest) (CurrencySingle, *_nethttp.Response, error)

	/*
	 * GetDefaultCurrency Get the user's default currency.
	 * Get the user's default currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetDefaultCurrencyRequest
	 */
	GetDefaultCurrency(ctx _context.Context) ApiGetDefaultCurrencyRequest

	/*
	 * GetDefaultCurrencyExecute executes the request
	 * @return CurrencySingle
	 */
	GetDefaultCurrencyExecute(r ApiGetDefaultCurrencyRequest) (CurrencySingle, *_nethttp.Response, error)

	/*
	 * ListAccountByCurrency List all accounts with this currency.
	 * List all accounts with this currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiListAccountByCurrencyRequest
	 */
	ListAccountByCurrency(ctx _context.Context, code string) ApiListAccountByCurrencyRequest

	/*
	 * ListAccountByCurrencyExecute executes the request
	 * @return AccountArray
	 */
	ListAccountByCurrencyExecute(r ApiListAccountByCurrencyRequest) (AccountArray, *_nethttp.Response, error)

	/*
	 * ListAvailableBudgetByCurrency List all available budgets with this currency.
	 * List all available budgets with this currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiListAvailableBudgetByCurrencyRequest
	 */
	ListAvailableBudgetByCurrency(ctx _context.Context, code string) ApiListAvailableBudgetByCurrencyRequest

	/*
	 * ListAvailableBudgetByCurrencyExecute executes the request
	 * @return AvailableBudgetArray
	 */
	ListAvailableBudgetByCurrencyExecute(r ApiListAvailableBudgetByCurrencyRequest) (AvailableBudgetArray, *_nethttp.Response, error)

	/*
	 * ListBillByCurrency List all bills with this currency.
	 * List all bills with this currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiListBillByCurrencyRequest
	 */
	ListBillByCurrency(ctx _context.Context, code string) ApiListBillByCurrencyRequest

	/*
	 * ListBillByCurrencyExecute executes the request
	 * @return BillArray
	 */
	ListBillByCurrencyExecute(r ApiListBillByCurrencyRequest) (BillArray, *_nethttp.Response, error)

	/*
	 * ListBudgetLimitByCurrency List all budget limits with this currency
	 * List all budget limits with this currency
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiListBudgetLimitByCurrencyRequest
	 */
	ListBudgetLimitByCurrency(ctx _context.Context, code string) ApiListBudgetLimitByCurrencyRequest

	/*
	 * ListBudgetLimitByCurrencyExecute executes the request
	 * @return BudgetLimitArray
	 */
	ListBudgetLimitByCurrencyExecute(r ApiListBudgetLimitByCurrencyRequest) (BudgetLimitArray, *_nethttp.Response, error)

	/*
	 * ListCurrency List all currencies.
	 * List all currencies.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiListCurrencyRequest
	 */
	ListCurrency(ctx _context.Context) ApiListCurrencyRequest

	/*
	 * ListCurrencyExecute executes the request
	 * @return CurrencyArray
	 */
	ListCurrencyExecute(r ApiListCurrencyRequest) (CurrencyArray, *_nethttp.Response, error)

	/*
	 * ListRecurrenceByCurrency List all recurring transactions with this currency.
	 * List all recurring transactions with this currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiListRecurrenceByCurrencyRequest
	 */
	ListRecurrenceByCurrency(ctx _context.Context, code string) ApiListRecurrenceByCurrencyRequest

	/*
	 * ListRecurrenceByCurrencyExecute executes the request
	 * @return RecurrenceArray
	 */
	ListRecurrenceByCurrencyExecute(r ApiListRecurrenceByCurrencyRequest) (RecurrenceArray, *_nethttp.Response, error)

	/*
	 * ListRuleByCurrency List all rules with this currency.
	 * List all rules with this currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiListRuleByCurrencyRequest
	 */
	ListRuleByCurrency(ctx _context.Context, code string) ApiListRuleByCurrencyRequest

	/*
	 * ListRuleByCurrencyExecute executes the request
	 * @return RuleArray
	 */
	ListRuleByCurrencyExecute(r ApiListRuleByCurrencyRequest) (RuleArray, *_nethttp.Response, error)

	/*
	 * ListTransactionByCurrency List all transactions with this currency.
	 * List all transactions with this currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiListTransactionByCurrencyRequest
	 */
	ListTransactionByCurrency(ctx _context.Context, code string) ApiListTransactionByCurrencyRequest

	/*
	 * ListTransactionByCurrencyExecute executes the request
	 * @return TransactionArray
	 */
	ListTransactionByCurrencyExecute(r ApiListTransactionByCurrencyRequest) (TransactionArray, *_nethttp.Response, error)

	/*
	 * StoreCurrency Store a new currency
	 * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiStoreCurrencyRequest
	 */
	StoreCurrency(ctx _context.Context) ApiStoreCurrencyRequest

	/*
	 * StoreCurrencyExecute executes the request
	 * @return CurrencySingle
	 */
	StoreCurrencyExecute(r ApiStoreCurrencyRequest) (CurrencySingle, *_nethttp.Response, error)

	/*
	 * UpdateCurrency Update existing currency.
	 * Update existing currency.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param code The currency code.
	 * @return ApiUpdateCurrencyRequest
	 */
	UpdateCurrency(ctx _context.Context, code string) ApiUpdateCurrencyRequest

	/*
	 * UpdateCurrencyExecute executes the request
	 * @return CurrencySingle
	 */
	UpdateCurrencyExecute(r ApiUpdateCurrencyRequest) (CurrencySingle, *_nethttp.Response, error)
}

// CurrenciesApiService CurrenciesApi service
type CurrenciesApiService service

type ApiDefaultCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
}


func (r ApiDefaultCurrencyRequest) Execute() (CurrencySingle, *_nethttp.Response, error) {
	return r.ApiService.DefaultCurrencyExecute(r)
}

/*
 * DefaultCurrency Make currency default currency.
 * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiDefaultCurrencyRequest
 */
func (a *CurrenciesApiService) DefaultCurrency(ctx _context.Context, code string) ApiDefaultCurrencyRequest {
	return ApiDefaultCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return CurrencySingle
 */
func (a *CurrenciesApiService) DefaultCurrencyExecute(r ApiDefaultCurrencyRequest) (CurrencySingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrencySingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.DefaultCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/default"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
}


func (r ApiDeleteCurrencyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteCurrencyExecute(r)
}

/*
 * DeleteCurrency Delete a currency.
 * Delete a currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiDeleteCurrencyRequest
 */
func (a *CurrenciesApiService) DeleteCurrency(ctx _context.Context, code string) ApiDeleteCurrencyRequest {
	return ApiDeleteCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 */
func (a *CurrenciesApiService) DeleteCurrencyExecute(r ApiDeleteCurrencyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.DeleteCurrency")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisableCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code int32
}


func (r ApiDisableCurrencyRequest) Execute() (CurrencySingle, *_nethttp.Response, error) {
	return r.ApiService.DisableCurrencyExecute(r)
}

/*
 * DisableCurrency Disable a currency.
 * Disable a currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiDisableCurrencyRequest
 */
func (a *CurrenciesApiService) DisableCurrency(ctx _context.Context, code int32) ApiDisableCurrencyRequest {
	return ApiDisableCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return CurrencySingle
 */
func (a *CurrenciesApiService) DisableCurrencyExecute(r ApiDisableCurrencyRequest) (CurrencySingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrencySingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.DisableCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnableCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
}


func (r ApiEnableCurrencyRequest) Execute() (CurrencySingle, *_nethttp.Response, error) {
	return r.ApiService.EnableCurrencyExecute(r)
}

/*
 * EnableCurrency Enable a single currency.
 * Enable a single currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiEnableCurrencyRequest
 */
func (a *CurrenciesApiService) EnableCurrency(ctx _context.Context, code string) ApiEnableCurrencyRequest {
	return ApiEnableCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return CurrencySingle
 */
func (a *CurrenciesApiService) EnableCurrencyExecute(r ApiEnableCurrencyRequest) (CurrencySingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrencySingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.EnableCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
}


func (r ApiGetCurrencyRequest) Execute() (CurrencySingle, *_nethttp.Response, error) {
	return r.ApiService.GetCurrencyExecute(r)
}

/*
 * GetCurrency Get a single currency.
 * Get a single currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiGetCurrencyRequest
 */
func (a *CurrenciesApiService) GetCurrency(ctx _context.Context, code string) ApiGetCurrencyRequest {
	return ApiGetCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return CurrencySingle
 */
func (a *CurrenciesApiService) GetCurrencyExecute(r ApiGetCurrencyRequest) (CurrencySingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrencySingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
}


func (r ApiGetDefaultCurrencyRequest) Execute() (CurrencySingle, *_nethttp.Response, error) {
	return r.ApiService.GetDefaultCurrencyExecute(r)
}

/*
 * GetDefaultCurrency Get the user's default currency.
 * Get the user's default currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDefaultCurrencyRequest
 */
func (a *CurrenciesApiService) GetDefaultCurrency(ctx _context.Context) ApiGetDefaultCurrencyRequest {
	return ApiGetDefaultCurrencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CurrencySingle
 */
func (a *CurrenciesApiService) GetDefaultCurrencyExecute(r ApiGetDefaultCurrencyRequest) (CurrencySingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrencySingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetDefaultCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountByCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
	page *int32
	date *string
	type_ *AccountTypeFilter
}

func (r ApiListAccountByCurrencyRequest) Page(page int32) ApiListAccountByCurrencyRequest {
	r.page = &page
	return r
}
func (r ApiListAccountByCurrencyRequest) Date(date string) ApiListAccountByCurrencyRequest {
	r.date = &date
	return r
}
func (r ApiListAccountByCurrencyRequest) Type_(type_ AccountTypeFilter) ApiListAccountByCurrencyRequest {
	r.type_ = &type_
	return r
}

func (r ApiListAccountByCurrencyRequest) Execute() (AccountArray, *_nethttp.Response, error) {
	return r.ApiService.ListAccountByCurrencyExecute(r)
}

/*
 * ListAccountByCurrency List all accounts with this currency.
 * List all accounts with this currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiListAccountByCurrencyRequest
 */
func (a *CurrenciesApiService) ListAccountByCurrency(ctx _context.Context, code string) ApiListAccountByCurrencyRequest {
	return ApiListAccountByCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return AccountArray
 */
func (a *CurrenciesApiService) ListAccountByCurrencyExecute(r ApiListAccountByCurrencyRequest) (AccountArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.ListAccountByCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.date != nil {
		localVarQueryParams.Add("date", parameterToString(*r.date, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailableBudgetByCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
	page *int32
}

func (r ApiListAvailableBudgetByCurrencyRequest) Page(page int32) ApiListAvailableBudgetByCurrencyRequest {
	r.page = &page
	return r
}

func (r ApiListAvailableBudgetByCurrencyRequest) Execute() (AvailableBudgetArray, *_nethttp.Response, error) {
	return r.ApiService.ListAvailableBudgetByCurrencyExecute(r)
}

/*
 * ListAvailableBudgetByCurrency List all available budgets with this currency.
 * List all available budgets with this currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiListAvailableBudgetByCurrencyRequest
 */
func (a *CurrenciesApiService) ListAvailableBudgetByCurrency(ctx _context.Context, code string) ApiListAvailableBudgetByCurrencyRequest {
	return ApiListAvailableBudgetByCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return AvailableBudgetArray
 */
func (a *CurrenciesApiService) ListAvailableBudgetByCurrencyExecute(r ApiListAvailableBudgetByCurrencyRequest) (AvailableBudgetArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AvailableBudgetArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.ListAvailableBudgetByCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/available_budgets"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillByCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
	page *int32
}

func (r ApiListBillByCurrencyRequest) Page(page int32) ApiListBillByCurrencyRequest {
	r.page = &page
	return r
}

func (r ApiListBillByCurrencyRequest) Execute() (BillArray, *_nethttp.Response, error) {
	return r.ApiService.ListBillByCurrencyExecute(r)
}

/*
 * ListBillByCurrency List all bills with this currency.
 * List all bills with this currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiListBillByCurrencyRequest
 */
func (a *CurrenciesApiService) ListBillByCurrency(ctx _context.Context, code string) ApiListBillByCurrencyRequest {
	return ApiListBillByCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return BillArray
 */
func (a *CurrenciesApiService) ListBillByCurrencyExecute(r ApiListBillByCurrencyRequest) (BillArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BillArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.ListBillByCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/bills"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBudgetLimitByCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
	page *int32
	start *string
	end *string
}

func (r ApiListBudgetLimitByCurrencyRequest) Page(page int32) ApiListBudgetLimitByCurrencyRequest {
	r.page = &page
	return r
}
func (r ApiListBudgetLimitByCurrencyRequest) Start(start string) ApiListBudgetLimitByCurrencyRequest {
	r.start = &start
	return r
}
func (r ApiListBudgetLimitByCurrencyRequest) End(end string) ApiListBudgetLimitByCurrencyRequest {
	r.end = &end
	return r
}

func (r ApiListBudgetLimitByCurrencyRequest) Execute() (BudgetLimitArray, *_nethttp.Response, error) {
	return r.ApiService.ListBudgetLimitByCurrencyExecute(r)
}

/*
 * ListBudgetLimitByCurrency List all budget limits with this currency
 * List all budget limits with this currency
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiListBudgetLimitByCurrencyRequest
 */
func (a *CurrenciesApiService) ListBudgetLimitByCurrency(ctx _context.Context, code string) ApiListBudgetLimitByCurrencyRequest {
	return ApiListBudgetLimitByCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return BudgetLimitArray
 */
func (a *CurrenciesApiService) ListBudgetLimitByCurrencyExecute(r ApiListBudgetLimitByCurrencyRequest) (BudgetLimitArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetLimitArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.ListBudgetLimitByCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/budget_limits"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	page *int32
}

func (r ApiListCurrencyRequest) Page(page int32) ApiListCurrencyRequest {
	r.page = &page
	return r
}

func (r ApiListCurrencyRequest) Execute() (CurrencyArray, *_nethttp.Response, error) {
	return r.ApiService.ListCurrencyExecute(r)
}

/*
 * ListCurrency List all currencies.
 * List all currencies.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListCurrencyRequest
 */
func (a *CurrenciesApiService) ListCurrency(ctx _context.Context) ApiListCurrencyRequest {
	return ApiListCurrencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CurrencyArray
 */
func (a *CurrenciesApiService) ListCurrencyExecute(r ApiListCurrencyRequest) (CurrencyArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrencyArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.ListCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRecurrenceByCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
	page *int32
}

func (r ApiListRecurrenceByCurrencyRequest) Page(page int32) ApiListRecurrenceByCurrencyRequest {
	r.page = &page
	return r
}

func (r ApiListRecurrenceByCurrencyRequest) Execute() (RecurrenceArray, *_nethttp.Response, error) {
	return r.ApiService.ListRecurrenceByCurrencyExecute(r)
}

/*
 * ListRecurrenceByCurrency List all recurring transactions with this currency.
 * List all recurring transactions with this currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiListRecurrenceByCurrencyRequest
 */
func (a *CurrenciesApiService) ListRecurrenceByCurrency(ctx _context.Context, code string) ApiListRecurrenceByCurrencyRequest {
	return ApiListRecurrenceByCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return RecurrenceArray
 */
func (a *CurrenciesApiService) ListRecurrenceByCurrencyExecute(r ApiListRecurrenceByCurrencyRequest) (RecurrenceArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RecurrenceArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.ListRecurrenceByCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/recurrences"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRuleByCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
	page *int32
}

func (r ApiListRuleByCurrencyRequest) Page(page int32) ApiListRuleByCurrencyRequest {
	r.page = &page
	return r
}

func (r ApiListRuleByCurrencyRequest) Execute() (RuleArray, *_nethttp.Response, error) {
	return r.ApiService.ListRuleByCurrencyExecute(r)
}

/*
 * ListRuleByCurrency List all rules with this currency.
 * List all rules with this currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiListRuleByCurrencyRequest
 */
func (a *CurrenciesApiService) ListRuleByCurrency(ctx _context.Context, code string) ApiListRuleByCurrencyRequest {
	return ApiListRuleByCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return RuleArray
 */
func (a *CurrenciesApiService) ListRuleByCurrencyExecute(r ApiListRuleByCurrencyRequest) (RuleArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RuleArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.ListRuleByCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionByCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
	page *int32
	start *string
	end *string
	type_ *TransactionTypeFilter
}

func (r ApiListTransactionByCurrencyRequest) Page(page int32) ApiListTransactionByCurrencyRequest {
	r.page = &page
	return r
}
func (r ApiListTransactionByCurrencyRequest) Start(start string) ApiListTransactionByCurrencyRequest {
	r.start = &start
	return r
}
func (r ApiListTransactionByCurrencyRequest) End(end string) ApiListTransactionByCurrencyRequest {
	r.end = &end
	return r
}
func (r ApiListTransactionByCurrencyRequest) Type_(type_ TransactionTypeFilter) ApiListTransactionByCurrencyRequest {
	r.type_ = &type_
	return r
}

func (r ApiListTransactionByCurrencyRequest) Execute() (TransactionArray, *_nethttp.Response, error) {
	return r.ApiService.ListTransactionByCurrencyExecute(r)
}

/*
 * ListTransactionByCurrency List all transactions with this currency.
 * List all transactions with this currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiListTransactionByCurrencyRequest
 */
func (a *CurrenciesApiService) ListTransactionByCurrency(ctx _context.Context, code string) ApiListTransactionByCurrencyRequest {
	return ApiListTransactionByCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return TransactionArray
 */
func (a *CurrenciesApiService) ListTransactionByCurrencyExecute(r ApiListTransactionByCurrencyRequest) (TransactionArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TransactionArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.ListTransactionByCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStoreCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	currencyStore *CurrencyStore
}

func (r ApiStoreCurrencyRequest) CurrencyStore(currencyStore CurrencyStore) ApiStoreCurrencyRequest {
	r.currencyStore = &currencyStore
	return r
}

func (r ApiStoreCurrencyRequest) Execute() (CurrencySingle, *_nethttp.Response, error) {
	return r.ApiService.StoreCurrencyExecute(r)
}

/*
 * StoreCurrency Store a new currency
 * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiStoreCurrencyRequest
 */
func (a *CurrenciesApiService) StoreCurrency(ctx _context.Context) ApiStoreCurrencyRequest {
	return ApiStoreCurrencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CurrencySingle
 */
func (a *CurrenciesApiService) StoreCurrencyExecute(r ApiStoreCurrencyRequest) (CurrencySingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrencySingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.StoreCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.currencyStore == nil {
		return localVarReturnValue, nil, reportError("currencyStore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.currencyStore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCurrencyRequest struct {
	ctx _context.Context
	ApiService CurrenciesApi
	code string
	currencyUpdate *CurrencyUpdate
}

func (r ApiUpdateCurrencyRequest) CurrencyUpdate(currencyUpdate CurrencyUpdate) ApiUpdateCurrencyRequest {
	r.currencyUpdate = &currencyUpdate
	return r
}

func (r ApiUpdateCurrencyRequest) Execute() (CurrencySingle, *_nethttp.Response, error) {
	return r.ApiService.UpdateCurrencyExecute(r)
}

/*
 * UpdateCurrency Update existing currency.
 * Update existing currency.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param code The currency code.
 * @return ApiUpdateCurrencyRequest
 */
func (a *CurrenciesApiService) UpdateCurrency(ctx _context.Context, code string) ApiUpdateCurrencyRequest {
	return ApiUpdateCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

/*
 * Execute executes the request
 * @return CurrencySingle
 */
func (a *CurrenciesApiService) UpdateCurrencyExecute(r ApiUpdateCurrencyRequest) (CurrencySingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrencySingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.UpdateCurrency")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/currencies/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", _neturl.PathEscape(parameterToString(r.code, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.currencyUpdate == nil {
		return localVarReturnValue, nil, reportError("currencyUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.api+json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.currencyUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
