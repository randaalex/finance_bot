/*
 * Firefly III API v1.5.2
 *
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2021-05-14T15:49:56+00:00 
 *
 * API version: 1.5.2
 * Contact: james@firefly-iii.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package firefly

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

type RuleGroupsApi interface {

	/*
	 * DeleteRuleGroup Delete a rule group.
	 * Delete a rule group.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the rule group.
	 * @return ApiDeleteRuleGroupRequest
	 */
	DeleteRuleGroup(ctx _context.Context, id int32) ApiDeleteRuleGroupRequest

	/*
	 * DeleteRuleGroupExecute executes the request
	 */
	DeleteRuleGroupExecute(r ApiDeleteRuleGroupRequest) (*_nethttp.Response, error)

	/*
	 * FireRuleGroup Fire the rule group on your transactions.
	 * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the rule group.
	 * @return ApiFireRuleGroupRequest
	 */
	FireRuleGroup(ctx _context.Context, id int32) ApiFireRuleGroupRequest

	/*
	 * FireRuleGroupExecute executes the request
	 */
	FireRuleGroupExecute(r ApiFireRuleGroupRequest) (*_nethttp.Response, error)

	/*
	 * GetRuleGroup Get a single rule group.
	 * Get a single rule group. This does not include the rules. For that, see below.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the rule group.
	 * @return ApiGetRuleGroupRequest
	 */
	GetRuleGroup(ctx _context.Context, id int32) ApiGetRuleGroupRequest

	/*
	 * GetRuleGroupExecute executes the request
	 * @return RuleGroupSingle
	 */
	GetRuleGroupExecute(r ApiGetRuleGroupRequest) (RuleGroupSingle, *_nethttp.Response, error)

	/*
	 * ListRuleByGroup List rules in this rule group.
	 * List rules in this rule group.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the rule group.
	 * @return ApiListRuleByGroupRequest
	 */
	ListRuleByGroup(ctx _context.Context, id int32) ApiListRuleByGroupRequest

	/*
	 * ListRuleByGroupExecute executes the request
	 * @return RuleArray
	 */
	ListRuleByGroupExecute(r ApiListRuleByGroupRequest) (RuleArray, *_nethttp.Response, error)

	/*
	 * ListRuleGroup List all rule groups.
	 * List all rule groups.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiListRuleGroupRequest
	 */
	ListRuleGroup(ctx _context.Context) ApiListRuleGroupRequest

	/*
	 * ListRuleGroupExecute executes the request
	 * @return RuleGroupArray
	 */
	ListRuleGroupExecute(r ApiListRuleGroupRequest) (RuleGroupArray, *_nethttp.Response, error)

	/*
	 * StoreRuleGroup Store a new rule group.
	 * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiStoreRuleGroupRequest
	 */
	StoreRuleGroup(ctx _context.Context) ApiStoreRuleGroupRequest

	/*
	 * StoreRuleGroupExecute executes the request
	 * @return RuleGroupSingle
	 */
	StoreRuleGroupExecute(r ApiStoreRuleGroupRequest) (RuleGroupSingle, *_nethttp.Response, error)

	/*
	 * TestRuleGroup Test which transactions would be hit by the rule group. No changes will be made.
	 * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the rule group.
	 * @return ApiTestRuleGroupRequest
	 */
	TestRuleGroup(ctx _context.Context, id int32) ApiTestRuleGroupRequest

	/*
	 * TestRuleGroupExecute executes the request
	 * @return TransactionArray
	 */
	TestRuleGroupExecute(r ApiTestRuleGroupRequest) (TransactionArray, *_nethttp.Response, error)

	/*
	 * UpdateRuleGroup Update existing rule group.
	 * Update existing rule group.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the rule group.
	 * @return ApiUpdateRuleGroupRequest
	 */
	UpdateRuleGroup(ctx _context.Context, id int32) ApiUpdateRuleGroupRequest

	/*
	 * UpdateRuleGroupExecute executes the request
	 * @return RuleGroupSingle
	 */
	UpdateRuleGroupExecute(r ApiUpdateRuleGroupRequest) (RuleGroupSingle, *_nethttp.Response, error)
}

// RuleGroupsApiService RuleGroupsApi service
type RuleGroupsApiService service

type ApiDeleteRuleGroupRequest struct {
	ctx _context.Context
	ApiService RuleGroupsApi
	id int32
}


func (r ApiDeleteRuleGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteRuleGroupExecute(r)
}

/*
 * DeleteRuleGroup Delete a rule group.
 * Delete a rule group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the rule group.
 * @return ApiDeleteRuleGroupRequest
 */
func (a *RuleGroupsApiService) DeleteRuleGroup(ctx _context.Context, id int32) ApiDeleteRuleGroupRequest {
	return ApiDeleteRuleGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *RuleGroupsApiService) DeleteRuleGroupExecute(r ApiDeleteRuleGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuleGroupsApiService.DeleteRuleGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rule_groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFireRuleGroupRequest struct {
	ctx _context.Context
	ApiService RuleGroupsApi
	id int32
	start *string
	end *string
	accounts *[]int64
}

func (r ApiFireRuleGroupRequest) Start(start string) ApiFireRuleGroupRequest {
	r.start = &start
	return r
}
func (r ApiFireRuleGroupRequest) End(end string) ApiFireRuleGroupRequest {
	r.end = &end
	return r
}
func (r ApiFireRuleGroupRequest) Accounts(accounts []int64) ApiFireRuleGroupRequest {
	r.accounts = &accounts
	return r
}

func (r ApiFireRuleGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.FireRuleGroupExecute(r)
}

/*
 * FireRuleGroup Fire the rule group on your transactions.
 * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the rule group.
 * @return ApiFireRuleGroupRequest
 */
func (a *RuleGroupsApiService) FireRuleGroup(ctx _context.Context, id int32) ApiFireRuleGroupRequest {
	return ApiFireRuleGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *RuleGroupsApiService) FireRuleGroupExecute(r ApiFireRuleGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuleGroupsApiService.FireRuleGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rule_groups/{id}/trigger"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRuleGroupRequest struct {
	ctx _context.Context
	ApiService RuleGroupsApi
	id int32
}


func (r ApiGetRuleGroupRequest) Execute() (RuleGroupSingle, *_nethttp.Response, error) {
	return r.ApiService.GetRuleGroupExecute(r)
}

/*
 * GetRuleGroup Get a single rule group.
 * Get a single rule group. This does not include the rules. For that, see below.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the rule group.
 * @return ApiGetRuleGroupRequest
 */
func (a *RuleGroupsApiService) GetRuleGroup(ctx _context.Context, id int32) ApiGetRuleGroupRequest {
	return ApiGetRuleGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return RuleGroupSingle
 */
func (a *RuleGroupsApiService) GetRuleGroupExecute(r ApiGetRuleGroupRequest) (RuleGroupSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RuleGroupSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuleGroupsApiService.GetRuleGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rule_groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRuleByGroupRequest struct {
	ctx _context.Context
	ApiService RuleGroupsApi
	id int32
	page *int32
}

func (r ApiListRuleByGroupRequest) Page(page int32) ApiListRuleByGroupRequest {
	r.page = &page
	return r
}

func (r ApiListRuleByGroupRequest) Execute() (RuleArray, *_nethttp.Response, error) {
	return r.ApiService.ListRuleByGroupExecute(r)
}

/*
 * ListRuleByGroup List rules in this rule group.
 * List rules in this rule group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the rule group.
 * @return ApiListRuleByGroupRequest
 */
func (a *RuleGroupsApiService) ListRuleByGroup(ctx _context.Context, id int32) ApiListRuleByGroupRequest {
	return ApiListRuleByGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return RuleArray
 */
func (a *RuleGroupsApiService) ListRuleByGroupExecute(r ApiListRuleByGroupRequest) (RuleArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RuleArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuleGroupsApiService.ListRuleByGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rule_groups/{id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRuleGroupRequest struct {
	ctx _context.Context
	ApiService RuleGroupsApi
	page *int32
}

func (r ApiListRuleGroupRequest) Page(page int32) ApiListRuleGroupRequest {
	r.page = &page
	return r
}

func (r ApiListRuleGroupRequest) Execute() (RuleGroupArray, *_nethttp.Response, error) {
	return r.ApiService.ListRuleGroupExecute(r)
}

/*
 * ListRuleGroup List all rule groups.
 * List all rule groups.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListRuleGroupRequest
 */
func (a *RuleGroupsApiService) ListRuleGroup(ctx _context.Context) ApiListRuleGroupRequest {
	return ApiListRuleGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return RuleGroupArray
 */
func (a *RuleGroupsApiService) ListRuleGroupExecute(r ApiListRuleGroupRequest) (RuleGroupArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RuleGroupArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuleGroupsApiService.ListRuleGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rule_groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStoreRuleGroupRequest struct {
	ctx _context.Context
	ApiService RuleGroupsApi
	ruleGroupStore *RuleGroupStore
}

func (r ApiStoreRuleGroupRequest) RuleGroupStore(ruleGroupStore RuleGroupStore) ApiStoreRuleGroupRequest {
	r.ruleGroupStore = &ruleGroupStore
	return r
}

func (r ApiStoreRuleGroupRequest) Execute() (RuleGroupSingle, *_nethttp.Response, error) {
	return r.ApiService.StoreRuleGroupExecute(r)
}

/*
 * StoreRuleGroup Store a new rule group.
 * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiStoreRuleGroupRequest
 */
func (a *RuleGroupsApiService) StoreRuleGroup(ctx _context.Context) ApiStoreRuleGroupRequest {
	return ApiStoreRuleGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return RuleGroupSingle
 */
func (a *RuleGroupsApiService) StoreRuleGroupExecute(r ApiStoreRuleGroupRequest) (RuleGroupSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RuleGroupSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuleGroupsApiService.StoreRuleGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rule_groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.ruleGroupStore == nil {
		return localVarReturnValue, nil, reportError("ruleGroupStore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ruleGroupStore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestRuleGroupRequest struct {
	ctx _context.Context
	ApiService RuleGroupsApi
	id int32
	page *int32
	start *string
	end *string
	searchLimit *int32
	triggeredLimit *int32
	accounts *[]int64
}

func (r ApiTestRuleGroupRequest) Page(page int32) ApiTestRuleGroupRequest {
	r.page = &page
	return r
}
func (r ApiTestRuleGroupRequest) Start(start string) ApiTestRuleGroupRequest {
	r.start = &start
	return r
}
func (r ApiTestRuleGroupRequest) End(end string) ApiTestRuleGroupRequest {
	r.end = &end
	return r
}
func (r ApiTestRuleGroupRequest) SearchLimit(searchLimit int32) ApiTestRuleGroupRequest {
	r.searchLimit = &searchLimit
	return r
}
func (r ApiTestRuleGroupRequest) TriggeredLimit(triggeredLimit int32) ApiTestRuleGroupRequest {
	r.triggeredLimit = &triggeredLimit
	return r
}
func (r ApiTestRuleGroupRequest) Accounts(accounts []int64) ApiTestRuleGroupRequest {
	r.accounts = &accounts
	return r
}

func (r ApiTestRuleGroupRequest) Execute() (TransactionArray, *_nethttp.Response, error) {
	return r.ApiService.TestRuleGroupExecute(r)
}

/*
 * TestRuleGroup Test which transactions would be hit by the rule group. No changes will be made.
 * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the rule group.
 * @return ApiTestRuleGroupRequest
 */
func (a *RuleGroupsApiService) TestRuleGroup(ctx _context.Context, id int32) ApiTestRuleGroupRequest {
	return ApiTestRuleGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return TransactionArray
 */
func (a *RuleGroupsApiService) TestRuleGroupExecute(r ApiTestRuleGroupRequest) (TransactionArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TransactionArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuleGroupsApiService.TestRuleGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rule_groups/{id}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.searchLimit != nil {
		localVarQueryParams.Add("search_limit", parameterToString(*r.searchLimit, ""))
	}
	if r.triggeredLimit != nil {
		localVarQueryParams.Add("triggered_limit", parameterToString(*r.triggeredLimit, ""))
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRuleGroupRequest struct {
	ctx _context.Context
	ApiService RuleGroupsApi
	id int32
	ruleGroupUpdate *RuleGroupUpdate
}

func (r ApiUpdateRuleGroupRequest) RuleGroupUpdate(ruleGroupUpdate RuleGroupUpdate) ApiUpdateRuleGroupRequest {
	r.ruleGroupUpdate = &ruleGroupUpdate
	return r
}

func (r ApiUpdateRuleGroupRequest) Execute() (RuleGroupSingle, *_nethttp.Response, error) {
	return r.ApiService.UpdateRuleGroupExecute(r)
}

/*
 * UpdateRuleGroup Update existing rule group.
 * Update existing rule group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the rule group.
 * @return ApiUpdateRuleGroupRequest
 */
func (a *RuleGroupsApiService) UpdateRuleGroup(ctx _context.Context, id int32) ApiUpdateRuleGroupRequest {
	return ApiUpdateRuleGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return RuleGroupSingle
 */
func (a *RuleGroupsApiService) UpdateRuleGroupExecute(r ApiUpdateRuleGroupRequest) (RuleGroupSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RuleGroupSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuleGroupsApiService.UpdateRuleGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rule_groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.ruleGroupUpdate == nil {
		return localVarReturnValue, nil, reportError("ruleGroupUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ruleGroupUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
