/*
 * Firefly III API v1.5.2
 *
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2021-05-14T15:49:56+00:00 
 *
 * API version: 1.5.2
 * Contact: james@firefly-iii.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package firefly

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

type InsightApi interface {

	/*
	 * InsightExpenseAsset Insight into expenses, grouped by asset account.
	 * This endpoint gives a summary of the expenses made by the user, grouped by asset account.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseAssetRequest
	 */
	InsightExpenseAsset(ctx _context.Context) ApiInsightExpenseAssetRequest

	/*
	 * InsightExpenseAssetExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightExpenseAssetExecute(r ApiInsightExpenseAssetRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseBill Insight into expenses, grouped by bill.
	 * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseBillRequest
	 */
	InsightExpenseBill(ctx _context.Context) ApiInsightExpenseBillRequest

	/*
	 * InsightExpenseBillExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightExpenseBillExecute(r ApiInsightExpenseBillRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseBudget Insight into expenses, grouped by budget.
	 * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseBudgetRequest
	 */
	InsightExpenseBudget(ctx _context.Context) ApiInsightExpenseBudgetRequest

	/*
	 * InsightExpenseBudgetExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightExpenseBudgetExecute(r ApiInsightExpenseBudgetRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseCategory Insight into expenses, grouped by category.
	 * This endpoint gives a summary of the expenses made by the user, grouped by (any) category.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseCategoryRequest
	 */
	InsightExpenseCategory(ctx _context.Context) ApiInsightExpenseCategoryRequest

	/*
	 * InsightExpenseCategoryExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightExpenseCategoryExecute(r ApiInsightExpenseCategoryRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseExpense Insight into expenses, grouped by expense account.
	 * This endpoint gives a summary of the expenses made by the user, grouped by expense account.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseExpenseRequest
	 */
	InsightExpenseExpense(ctx _context.Context) ApiInsightExpenseExpenseRequest

	/*
	 * InsightExpenseExpenseExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightExpenseExpenseExecute(r ApiInsightExpenseExpenseRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseNoBill Insight into expenses, without bill.
	 * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseNoBillRequest
	 */
	InsightExpenseNoBill(ctx _context.Context) ApiInsightExpenseNoBillRequest

	/*
	 * InsightExpenseNoBillExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightExpenseNoBillExecute(r ApiInsightExpenseNoBillRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseNoBudget Insight into expenses, without budget.
	 * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseNoBudgetRequest
	 */
	InsightExpenseNoBudget(ctx _context.Context) ApiInsightExpenseNoBudgetRequest

	/*
	 * InsightExpenseNoBudgetExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightExpenseNoBudgetExecute(r ApiInsightExpenseNoBudgetRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseNoCategory Insight into expenses, without category.
	 * This endpoint gives a summary of the expenses made by the user, including only expenses with no category.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseNoCategoryRequest
	 */
	InsightExpenseNoCategory(ctx _context.Context) ApiInsightExpenseNoCategoryRequest

	/*
	 * InsightExpenseNoCategoryExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightExpenseNoCategoryExecute(r ApiInsightExpenseNoCategoryRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseNoTag Insight into expenses, without tag.
	 * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseNoTagRequest
	 */
	InsightExpenseNoTag(ctx _context.Context) ApiInsightExpenseNoTagRequest

	/*
	 * InsightExpenseNoTagExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightExpenseNoTagExecute(r ApiInsightExpenseNoTagRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseTag Insight into expenses, grouped by tag.
	 * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseTagRequest
	 */
	InsightExpenseTag(ctx _context.Context) ApiInsightExpenseTagRequest

	/*
	 * InsightExpenseTagExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightExpenseTagExecute(r ApiInsightExpenseTagRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightExpenseTotal Insight into total expenses.
	 * This endpoint gives a sum of the total expenses made by the user.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightExpenseTotalRequest
	 */
	InsightExpenseTotal(ctx _context.Context) ApiInsightExpenseTotalRequest

	/*
	 * InsightExpenseTotalExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightExpenseTotalExecute(r ApiInsightExpenseTotalRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightIncomeAsset Insight into income, grouped by asset account.
	 * This endpoint gives a summary of the income received by the user, grouped by asset account.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightIncomeAssetRequest
	 */
	InsightIncomeAsset(ctx _context.Context) ApiInsightIncomeAssetRequest

	/*
	 * InsightIncomeAssetExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightIncomeAssetExecute(r ApiInsightIncomeAssetRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightIncomeCategory Insight into income, grouped by category.
	 * This endpoint gives a summary of the income received by the user, grouped by (any) category.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightIncomeCategoryRequest
	 */
	InsightIncomeCategory(ctx _context.Context) ApiInsightIncomeCategoryRequest

	/*
	 * InsightIncomeCategoryExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightIncomeCategoryExecute(r ApiInsightIncomeCategoryRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightIncomeNoCategory Insight into income, without category.
	 * This endpoint gives a summary of the income received by the user, including only income with no category.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightIncomeNoCategoryRequest
	 */
	InsightIncomeNoCategory(ctx _context.Context) ApiInsightIncomeNoCategoryRequest

	/*
	 * InsightIncomeNoCategoryExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightIncomeNoCategoryExecute(r ApiInsightIncomeNoCategoryRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightIncomeNoTag Insight into income, without tag.
	 * This endpoint gives a summary of the income received by the user, including only income with no tag.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightIncomeNoTagRequest
	 */
	InsightIncomeNoTag(ctx _context.Context) ApiInsightIncomeNoTagRequest

	/*
	 * InsightIncomeNoTagExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightIncomeNoTagExecute(r ApiInsightIncomeNoTagRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightIncomeRevenue Insight into income, grouped by revenue account.
	 * This endpoint gives a summary of the income received by the user, grouped by revenue account.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightIncomeRevenueRequest
	 */
	InsightIncomeRevenue(ctx _context.Context) ApiInsightIncomeRevenueRequest

	/*
	 * InsightIncomeRevenueExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightIncomeRevenueExecute(r ApiInsightIncomeRevenueRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightIncomeTag Insight into income, grouped by tag.
	 * This endpoint gives a summary of the income received by the user, grouped by (any) tag.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightIncomeTagRequest
	 */
	InsightIncomeTag(ctx _context.Context) ApiInsightIncomeTagRequest

	/*
	 * InsightIncomeTagExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightIncomeTagExecute(r ApiInsightIncomeTagRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightIncomeTotal Insight into total income.
	 * This endpoint gives a sum of the total income received by the user.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightIncomeTotalRequest
	 */
	InsightIncomeTotal(ctx _context.Context) ApiInsightIncomeTotalRequest

	/*
	 * InsightIncomeTotalExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightIncomeTotalExecute(r ApiInsightIncomeTotalRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightTransferCategory Insight into transfers, grouped by category.
	 * This endpoint gives a summary of the transfers made by the user, grouped by (any) category.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightTransferCategoryRequest
	 */
	InsightTransferCategory(ctx _context.Context) ApiInsightTransferCategoryRequest

	/*
	 * InsightTransferCategoryExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightTransferCategoryExecute(r ApiInsightTransferCategoryRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightTransferNoCategory Insight into transfers, without category.
	 * This endpoint gives a summary of the transfers made by the user, including only transfers with no category.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightTransferNoCategoryRequest
	 */
	InsightTransferNoCategory(ctx _context.Context) ApiInsightTransferNoCategoryRequest

	/*
	 * InsightTransferNoCategoryExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightTransferNoCategoryExecute(r ApiInsightTransferNoCategoryRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightTransferNoTag Insight into expenses, without tag.
	 * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightTransferNoTagRequest
	 */
	InsightTransferNoTag(ctx _context.Context) ApiInsightTransferNoTagRequest

	/*
	 * InsightTransferNoTagExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightTransferNoTagExecute(r ApiInsightTransferNoTagRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightTransferTag Insight into transfers, grouped by tag.
	 * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightTransferTagRequest
	 */
	InsightTransferTag(ctx _context.Context) ApiInsightTransferTagRequest

	/*
	 * InsightTransferTagExecute executes the request
	 * @return []InsightGroupEntry
	 */
	InsightTransferTagExecute(r ApiInsightTransferTagRequest) ([]InsightGroupEntry, *_nethttp.Response, error)

	/*
	 * InsightTransferTotal Insight into total transfers.
	 * This endpoint gives a sum of the total amount transfers made by the user.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightTransferTotalRequest
	 */
	InsightTransferTotal(ctx _context.Context) ApiInsightTransferTotalRequest

	/*
	 * InsightTransferTotalExecute executes the request
	 * @return []InsightTotalEntry
	 */
	InsightTransferTotalExecute(r ApiInsightTransferTotalRequest) ([]InsightTotalEntry, *_nethttp.Response, error)

	/*
	 * InsightTransfers Insight into transfers, grouped by account.
	 * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiInsightTransfersRequest
	 */
	InsightTransfers(ctx _context.Context) ApiInsightTransfersRequest

	/*
	 * InsightTransfersExecute executes the request
	 * @return []InsightTransferEntry
	 */
	InsightTransfersExecute(r ApiInsightTransfersRequest) ([]InsightTransferEntry, *_nethttp.Response, error)
}

// InsightApiService InsightApi service
type InsightApiService service

type ApiInsightExpenseAssetRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightExpenseAssetRequest) Start(start string) ApiInsightExpenseAssetRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseAssetRequest) End(end string) ApiInsightExpenseAssetRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseAssetRequest) Accounts(accounts []int64) ApiInsightExpenseAssetRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseAssetRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseAssetExecute(r)
}

/*
 * InsightExpenseAsset Insight into expenses, grouped by asset account.
 * This endpoint gives a summary of the expenses made by the user, grouped by asset account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseAssetRequest
 */
func (a *InsightApiService) InsightExpenseAsset(ctx _context.Context) ApiInsightExpenseAssetRequest {
	return ApiInsightExpenseAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightExpenseAssetExecute(r ApiInsightExpenseAssetRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseAsset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseBillRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	bills *[]int64
	accounts *[]int64
}

func (r ApiInsightExpenseBillRequest) Start(start string) ApiInsightExpenseBillRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseBillRequest) End(end string) ApiInsightExpenseBillRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseBillRequest) Bills(bills []int64) ApiInsightExpenseBillRequest {
	r.bills = &bills
	return r
}
func (r ApiInsightExpenseBillRequest) Accounts(accounts []int64) ApiInsightExpenseBillRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseBillRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseBillExecute(r)
}

/*
 * InsightExpenseBill Insight into expenses, grouped by bill.
 * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseBillRequest
 */
func (a *InsightApiService) InsightExpenseBill(ctx _context.Context) ApiInsightExpenseBillRequest {
	return ApiInsightExpenseBillRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightExpenseBillExecute(r ApiInsightExpenseBillRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseBill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/bill"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.bills != nil {
		t := *r.bills
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("bills[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("bills[]", parameterToString(t, "multi"))
		}
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseBudgetRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	budgets *[]int64
	accounts *[]int64
}

func (r ApiInsightExpenseBudgetRequest) Start(start string) ApiInsightExpenseBudgetRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseBudgetRequest) End(end string) ApiInsightExpenseBudgetRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseBudgetRequest) Budgets(budgets []int64) ApiInsightExpenseBudgetRequest {
	r.budgets = &budgets
	return r
}
func (r ApiInsightExpenseBudgetRequest) Accounts(accounts []int64) ApiInsightExpenseBudgetRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseBudgetRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseBudgetExecute(r)
}

/*
 * InsightExpenseBudget Insight into expenses, grouped by budget.
 * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseBudgetRequest
 */
func (a *InsightApiService) InsightExpenseBudget(ctx _context.Context) ApiInsightExpenseBudgetRequest {
	return ApiInsightExpenseBudgetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightExpenseBudgetExecute(r ApiInsightExpenseBudgetRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/budget"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.budgets != nil {
		t := *r.budgets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("budgets[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("budgets[]", parameterToString(t, "multi"))
		}
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseCategoryRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	categories *[]int64
	accounts *[]int64
}

func (r ApiInsightExpenseCategoryRequest) Start(start string) ApiInsightExpenseCategoryRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseCategoryRequest) End(end string) ApiInsightExpenseCategoryRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseCategoryRequest) Categories(categories []int64) ApiInsightExpenseCategoryRequest {
	r.categories = &categories
	return r
}
func (r ApiInsightExpenseCategoryRequest) Accounts(accounts []int64) ApiInsightExpenseCategoryRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseCategoryRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseCategoryExecute(r)
}

/*
 * InsightExpenseCategory Insight into expenses, grouped by category.
 * This endpoint gives a summary of the expenses made by the user, grouped by (any) category.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseCategoryRequest
 */
func (a *InsightApiService) InsightExpenseCategory(ctx _context.Context) ApiInsightExpenseCategoryRequest {
	return ApiInsightExpenseCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightExpenseCategoryExecute(r ApiInsightExpenseCategoryRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseCategory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.categories != nil {
		t := *r.categories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("categories[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("categories[]", parameterToString(t, "multi"))
		}
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseExpenseRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightExpenseExpenseRequest) Start(start string) ApiInsightExpenseExpenseRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseExpenseRequest) End(end string) ApiInsightExpenseExpenseRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseExpenseRequest) Accounts(accounts []int64) ApiInsightExpenseExpenseRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseExpenseRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseExpenseExecute(r)
}

/*
 * InsightExpenseExpense Insight into expenses, grouped by expense account.
 * This endpoint gives a summary of the expenses made by the user, grouped by expense account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseExpenseRequest
 */
func (a *InsightApiService) InsightExpenseExpense(ctx _context.Context) ApiInsightExpenseExpenseRequest {
	return ApiInsightExpenseExpenseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightExpenseExpenseExecute(r ApiInsightExpenseExpenseRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseExpense")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/expense"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseNoBillRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightExpenseNoBillRequest) Start(start string) ApiInsightExpenseNoBillRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseNoBillRequest) End(end string) ApiInsightExpenseNoBillRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseNoBillRequest) Accounts(accounts []int64) ApiInsightExpenseNoBillRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseNoBillRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseNoBillExecute(r)
}

/*
 * InsightExpenseNoBill Insight into expenses, without bill.
 * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseNoBillRequest
 */
func (a *InsightApiService) InsightExpenseNoBill(ctx _context.Context) ApiInsightExpenseNoBillRequest {
	return ApiInsightExpenseNoBillRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightExpenseNoBillExecute(r ApiInsightExpenseNoBillRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseNoBill")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/no-bill"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseNoBudgetRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightExpenseNoBudgetRequest) Start(start string) ApiInsightExpenseNoBudgetRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseNoBudgetRequest) End(end string) ApiInsightExpenseNoBudgetRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseNoBudgetRequest) Accounts(accounts []int64) ApiInsightExpenseNoBudgetRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseNoBudgetRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseNoBudgetExecute(r)
}

/*
 * InsightExpenseNoBudget Insight into expenses, without budget.
 * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseNoBudgetRequest
 */
func (a *InsightApiService) InsightExpenseNoBudget(ctx _context.Context) ApiInsightExpenseNoBudgetRequest {
	return ApiInsightExpenseNoBudgetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightExpenseNoBudgetExecute(r ApiInsightExpenseNoBudgetRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseNoBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/no-budget"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseNoCategoryRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightExpenseNoCategoryRequest) Start(start string) ApiInsightExpenseNoCategoryRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseNoCategoryRequest) End(end string) ApiInsightExpenseNoCategoryRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseNoCategoryRequest) Accounts(accounts []int64) ApiInsightExpenseNoCategoryRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseNoCategoryRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseNoCategoryExecute(r)
}

/*
 * InsightExpenseNoCategory Insight into expenses, without category.
 * This endpoint gives a summary of the expenses made by the user, including only expenses with no category.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseNoCategoryRequest
 */
func (a *InsightApiService) InsightExpenseNoCategory(ctx _context.Context) ApiInsightExpenseNoCategoryRequest {
	return ApiInsightExpenseNoCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightExpenseNoCategoryExecute(r ApiInsightExpenseNoCategoryRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseNoCategory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/no-category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseNoTagRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightExpenseNoTagRequest) Start(start string) ApiInsightExpenseNoTagRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseNoTagRequest) End(end string) ApiInsightExpenseNoTagRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseNoTagRequest) Accounts(accounts []int64) ApiInsightExpenseNoTagRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseNoTagRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseNoTagExecute(r)
}

/*
 * InsightExpenseNoTag Insight into expenses, without tag.
 * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseNoTagRequest
 */
func (a *InsightApiService) InsightExpenseNoTag(ctx _context.Context) ApiInsightExpenseNoTagRequest {
	return ApiInsightExpenseNoTagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightExpenseNoTagExecute(r ApiInsightExpenseNoTagRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseNoTag")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/no-tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseTagRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	tags *[]int64
	accounts *[]int64
}

func (r ApiInsightExpenseTagRequest) Start(start string) ApiInsightExpenseTagRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseTagRequest) End(end string) ApiInsightExpenseTagRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseTagRequest) Tags(tags []int64) ApiInsightExpenseTagRequest {
	r.tags = &tags
	return r
}
func (r ApiInsightExpenseTagRequest) Accounts(accounts []int64) ApiInsightExpenseTagRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseTagRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseTagExecute(r)
}

/*
 * InsightExpenseTag Insight into expenses, grouped by tag.
 * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseTagRequest
 */
func (a *InsightApiService) InsightExpenseTag(ctx _context.Context) ApiInsightExpenseTagRequest {
	return ApiInsightExpenseTagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightExpenseTagExecute(r ApiInsightExpenseTagRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseTag")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tags[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tags[]", parameterToString(t, "multi"))
		}
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightExpenseTotalRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightExpenseTotalRequest) Start(start string) ApiInsightExpenseTotalRequest {
	r.start = &start
	return r
}
func (r ApiInsightExpenseTotalRequest) End(end string) ApiInsightExpenseTotalRequest {
	r.end = &end
	return r
}
func (r ApiInsightExpenseTotalRequest) Accounts(accounts []int64) ApiInsightExpenseTotalRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightExpenseTotalRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightExpenseTotalExecute(r)
}

/*
 * InsightExpenseTotal Insight into total expenses.
 * This endpoint gives a sum of the total expenses made by the user.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightExpenseTotalRequest
 */
func (a *InsightApiService) InsightExpenseTotal(ctx _context.Context) ApiInsightExpenseTotalRequest {
	return ApiInsightExpenseTotalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightExpenseTotalExecute(r ApiInsightExpenseTotalRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightExpenseTotal")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/expense/total"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightIncomeAssetRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightIncomeAssetRequest) Start(start string) ApiInsightIncomeAssetRequest {
	r.start = &start
	return r
}
func (r ApiInsightIncomeAssetRequest) End(end string) ApiInsightIncomeAssetRequest {
	r.end = &end
	return r
}
func (r ApiInsightIncomeAssetRequest) Accounts(accounts []int64) ApiInsightIncomeAssetRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightIncomeAssetRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightIncomeAssetExecute(r)
}

/*
 * InsightIncomeAsset Insight into income, grouped by asset account.
 * This endpoint gives a summary of the income received by the user, grouped by asset account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightIncomeAssetRequest
 */
func (a *InsightApiService) InsightIncomeAsset(ctx _context.Context) ApiInsightIncomeAssetRequest {
	return ApiInsightIncomeAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightIncomeAssetExecute(r ApiInsightIncomeAssetRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightIncomeAsset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/income/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightIncomeCategoryRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	categories *[]int64
	accounts *[]int64
}

func (r ApiInsightIncomeCategoryRequest) Start(start string) ApiInsightIncomeCategoryRequest {
	r.start = &start
	return r
}
func (r ApiInsightIncomeCategoryRequest) End(end string) ApiInsightIncomeCategoryRequest {
	r.end = &end
	return r
}
func (r ApiInsightIncomeCategoryRequest) Categories(categories []int64) ApiInsightIncomeCategoryRequest {
	r.categories = &categories
	return r
}
func (r ApiInsightIncomeCategoryRequest) Accounts(accounts []int64) ApiInsightIncomeCategoryRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightIncomeCategoryRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightIncomeCategoryExecute(r)
}

/*
 * InsightIncomeCategory Insight into income, grouped by category.
 * This endpoint gives a summary of the income received by the user, grouped by (any) category.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightIncomeCategoryRequest
 */
func (a *InsightApiService) InsightIncomeCategory(ctx _context.Context) ApiInsightIncomeCategoryRequest {
	return ApiInsightIncomeCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightIncomeCategoryExecute(r ApiInsightIncomeCategoryRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightIncomeCategory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/income/category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.categories != nil {
		t := *r.categories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("categories[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("categories[]", parameterToString(t, "multi"))
		}
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightIncomeNoCategoryRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightIncomeNoCategoryRequest) Start(start string) ApiInsightIncomeNoCategoryRequest {
	r.start = &start
	return r
}
func (r ApiInsightIncomeNoCategoryRequest) End(end string) ApiInsightIncomeNoCategoryRequest {
	r.end = &end
	return r
}
func (r ApiInsightIncomeNoCategoryRequest) Accounts(accounts []int64) ApiInsightIncomeNoCategoryRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightIncomeNoCategoryRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightIncomeNoCategoryExecute(r)
}

/*
 * InsightIncomeNoCategory Insight into income, without category.
 * This endpoint gives a summary of the income received by the user, including only income with no category.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightIncomeNoCategoryRequest
 */
func (a *InsightApiService) InsightIncomeNoCategory(ctx _context.Context) ApiInsightIncomeNoCategoryRequest {
	return ApiInsightIncomeNoCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightIncomeNoCategoryExecute(r ApiInsightIncomeNoCategoryRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightIncomeNoCategory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/income/no-category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightIncomeNoTagRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightIncomeNoTagRequest) Start(start string) ApiInsightIncomeNoTagRequest {
	r.start = &start
	return r
}
func (r ApiInsightIncomeNoTagRequest) End(end string) ApiInsightIncomeNoTagRequest {
	r.end = &end
	return r
}
func (r ApiInsightIncomeNoTagRequest) Accounts(accounts []int64) ApiInsightIncomeNoTagRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightIncomeNoTagRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightIncomeNoTagExecute(r)
}

/*
 * InsightIncomeNoTag Insight into income, without tag.
 * This endpoint gives a summary of the income received by the user, including only income with no tag.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightIncomeNoTagRequest
 */
func (a *InsightApiService) InsightIncomeNoTag(ctx _context.Context) ApiInsightIncomeNoTagRequest {
	return ApiInsightIncomeNoTagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightIncomeNoTagExecute(r ApiInsightIncomeNoTagRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightIncomeNoTag")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/income/no-tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightIncomeRevenueRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightIncomeRevenueRequest) Start(start string) ApiInsightIncomeRevenueRequest {
	r.start = &start
	return r
}
func (r ApiInsightIncomeRevenueRequest) End(end string) ApiInsightIncomeRevenueRequest {
	r.end = &end
	return r
}
func (r ApiInsightIncomeRevenueRequest) Accounts(accounts []int64) ApiInsightIncomeRevenueRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightIncomeRevenueRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightIncomeRevenueExecute(r)
}

/*
 * InsightIncomeRevenue Insight into income, grouped by revenue account.
 * This endpoint gives a summary of the income received by the user, grouped by revenue account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightIncomeRevenueRequest
 */
func (a *InsightApiService) InsightIncomeRevenue(ctx _context.Context) ApiInsightIncomeRevenueRequest {
	return ApiInsightIncomeRevenueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightIncomeRevenueExecute(r ApiInsightIncomeRevenueRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightIncomeRevenue")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/income/revenue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightIncomeTagRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	tags *[]int64
	accounts *[]int64
}

func (r ApiInsightIncomeTagRequest) Start(start string) ApiInsightIncomeTagRequest {
	r.start = &start
	return r
}
func (r ApiInsightIncomeTagRequest) End(end string) ApiInsightIncomeTagRequest {
	r.end = &end
	return r
}
func (r ApiInsightIncomeTagRequest) Tags(tags []int64) ApiInsightIncomeTagRequest {
	r.tags = &tags
	return r
}
func (r ApiInsightIncomeTagRequest) Accounts(accounts []int64) ApiInsightIncomeTagRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightIncomeTagRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightIncomeTagExecute(r)
}

/*
 * InsightIncomeTag Insight into income, grouped by tag.
 * This endpoint gives a summary of the income received by the user, grouped by (any) tag.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightIncomeTagRequest
 */
func (a *InsightApiService) InsightIncomeTag(ctx _context.Context) ApiInsightIncomeTagRequest {
	return ApiInsightIncomeTagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightIncomeTagExecute(r ApiInsightIncomeTagRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightIncomeTag")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/income/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tags[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tags[]", parameterToString(t, "multi"))
		}
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightIncomeTotalRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightIncomeTotalRequest) Start(start string) ApiInsightIncomeTotalRequest {
	r.start = &start
	return r
}
func (r ApiInsightIncomeTotalRequest) End(end string) ApiInsightIncomeTotalRequest {
	r.end = &end
	return r
}
func (r ApiInsightIncomeTotalRequest) Accounts(accounts []int64) ApiInsightIncomeTotalRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightIncomeTotalRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightIncomeTotalExecute(r)
}

/*
 * InsightIncomeTotal Insight into total income.
 * This endpoint gives a sum of the total income received by the user.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightIncomeTotalRequest
 */
func (a *InsightApiService) InsightIncomeTotal(ctx _context.Context) ApiInsightIncomeTotalRequest {
	return ApiInsightIncomeTotalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightIncomeTotalExecute(r ApiInsightIncomeTotalRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightIncomeTotal")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/income/total"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightTransferCategoryRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	categories *[]int64
	accounts *[]int64
}

func (r ApiInsightTransferCategoryRequest) Start(start string) ApiInsightTransferCategoryRequest {
	r.start = &start
	return r
}
func (r ApiInsightTransferCategoryRequest) End(end string) ApiInsightTransferCategoryRequest {
	r.end = &end
	return r
}
func (r ApiInsightTransferCategoryRequest) Categories(categories []int64) ApiInsightTransferCategoryRequest {
	r.categories = &categories
	return r
}
func (r ApiInsightTransferCategoryRequest) Accounts(accounts []int64) ApiInsightTransferCategoryRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightTransferCategoryRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightTransferCategoryExecute(r)
}

/*
 * InsightTransferCategory Insight into transfers, grouped by category.
 * This endpoint gives a summary of the transfers made by the user, grouped by (any) category.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightTransferCategoryRequest
 */
func (a *InsightApiService) InsightTransferCategory(ctx _context.Context) ApiInsightTransferCategoryRequest {
	return ApiInsightTransferCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightTransferCategoryExecute(r ApiInsightTransferCategoryRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightTransferCategory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/transfer/category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.categories != nil {
		t := *r.categories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("categories[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("categories[]", parameterToString(t, "multi"))
		}
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightTransferNoCategoryRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightTransferNoCategoryRequest) Start(start string) ApiInsightTransferNoCategoryRequest {
	r.start = &start
	return r
}
func (r ApiInsightTransferNoCategoryRequest) End(end string) ApiInsightTransferNoCategoryRequest {
	r.end = &end
	return r
}
func (r ApiInsightTransferNoCategoryRequest) Accounts(accounts []int64) ApiInsightTransferNoCategoryRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightTransferNoCategoryRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightTransferNoCategoryExecute(r)
}

/*
 * InsightTransferNoCategory Insight into transfers, without category.
 * This endpoint gives a summary of the transfers made by the user, including only transfers with no category.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightTransferNoCategoryRequest
 */
func (a *InsightApiService) InsightTransferNoCategory(ctx _context.Context) ApiInsightTransferNoCategoryRequest {
	return ApiInsightTransferNoCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightTransferNoCategoryExecute(r ApiInsightTransferNoCategoryRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightTransferNoCategory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/transfer/no-category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightTransferNoTagRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightTransferNoTagRequest) Start(start string) ApiInsightTransferNoTagRequest {
	r.start = &start
	return r
}
func (r ApiInsightTransferNoTagRequest) End(end string) ApiInsightTransferNoTagRequest {
	r.end = &end
	return r
}
func (r ApiInsightTransferNoTagRequest) Accounts(accounts []int64) ApiInsightTransferNoTagRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightTransferNoTagRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightTransferNoTagExecute(r)
}

/*
 * InsightTransferNoTag Insight into expenses, without tag.
 * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightTransferNoTagRequest
 */
func (a *InsightApiService) InsightTransferNoTag(ctx _context.Context) ApiInsightTransferNoTagRequest {
	return ApiInsightTransferNoTagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightTransferNoTagExecute(r ApiInsightTransferNoTagRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightTransferNoTag")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/transfer/no-tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightTransferTagRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	tags *[]int64
	accounts *[]int64
}

func (r ApiInsightTransferTagRequest) Start(start string) ApiInsightTransferTagRequest {
	r.start = &start
	return r
}
func (r ApiInsightTransferTagRequest) End(end string) ApiInsightTransferTagRequest {
	r.end = &end
	return r
}
func (r ApiInsightTransferTagRequest) Tags(tags []int64) ApiInsightTransferTagRequest {
	r.tags = &tags
	return r
}
func (r ApiInsightTransferTagRequest) Accounts(accounts []int64) ApiInsightTransferTagRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightTransferTagRequest) Execute() ([]InsightGroupEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightTransferTagExecute(r)
}

/*
 * InsightTransferTag Insight into transfers, grouped by tag.
 * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightTransferTagRequest
 */
func (a *InsightApiService) InsightTransferTag(ctx _context.Context) ApiInsightTransferTagRequest {
	return ApiInsightTransferTagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightGroupEntry
 */
func (a *InsightApiService) InsightTransferTagExecute(r ApiInsightTransferTagRequest) ([]InsightGroupEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightGroupEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightTransferTag")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/transfer/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tags[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tags[]", parameterToString(t, "multi"))
		}
	}
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightTransferTotalRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightTransferTotalRequest) Start(start string) ApiInsightTransferTotalRequest {
	r.start = &start
	return r
}
func (r ApiInsightTransferTotalRequest) End(end string) ApiInsightTransferTotalRequest {
	r.end = &end
	return r
}
func (r ApiInsightTransferTotalRequest) Accounts(accounts []int64) ApiInsightTransferTotalRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightTransferTotalRequest) Execute() ([]InsightTotalEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightTransferTotalExecute(r)
}

/*
 * InsightTransferTotal Insight into total transfers.
 * This endpoint gives a sum of the total amount transfers made by the user.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightTransferTotalRequest
 */
func (a *InsightApiService) InsightTransferTotal(ctx _context.Context) ApiInsightTransferTotalRequest {
	return ApiInsightTransferTotalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTotalEntry
 */
func (a *InsightApiService) InsightTransferTotalExecute(r ApiInsightTransferTotalRequest) ([]InsightTotalEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTotalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightTransferTotal")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/transfer/total"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightTransfersRequest struct {
	ctx _context.Context
	ApiService InsightApi
	start *string
	end *string
	accounts *[]int64
}

func (r ApiInsightTransfersRequest) Start(start string) ApiInsightTransfersRequest {
	r.start = &start
	return r
}
func (r ApiInsightTransfersRequest) End(end string) ApiInsightTransfersRequest {
	r.end = &end
	return r
}
func (r ApiInsightTransfersRequest) Accounts(accounts []int64) ApiInsightTransfersRequest {
	r.accounts = &accounts
	return r
}

func (r ApiInsightTransfersRequest) Execute() ([]InsightTransferEntry, *_nethttp.Response, error) {
	return r.ApiService.InsightTransfersExecute(r)
}

/*
 * InsightTransfers Insight into transfers, grouped by account.
 * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiInsightTransfersRequest
 */
func (a *InsightApiService) InsightTransfers(ctx _context.Context) ApiInsightTransfersRequest {
	return ApiInsightTransfersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []InsightTransferEntry
 */
func (a *InsightApiService) InsightTransfersExecute(r ApiInsightTransfersRequest) ([]InsightTransferEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InsightTransferEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightApiService.InsightTransfers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/insight/transfer/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.accounts != nil {
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accounts[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accounts[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
