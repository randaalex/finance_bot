/*
 * Firefly III API v1.5.2
 *
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2021-05-14T15:49:56+00:00 
 *
 * API version: 1.5.2
 * Contact: james@firefly-iii.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package firefly

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type BudgetsApi interface {

	/*
	 * DeleteBudget Delete a budget.
	 * Delete a budget. Transactions will not be deleted.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the budget.
	 * @return ApiDeleteBudgetRequest
	 */
	DeleteBudget(ctx _context.Context, id int32) ApiDeleteBudgetRequest

	/*
	 * DeleteBudgetExecute executes the request
	 */
	DeleteBudgetExecute(r ApiDeleteBudgetRequest) (*_nethttp.Response, error)

	/*
	 * DeleteBudgetLimit Delete a budget limit.
	 * Delete a budget limit.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the budget. The budget limit MUST be associated to the budget ID.
	 * @param limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
	 * @return ApiDeleteBudgetLimitRequest
	 */
	DeleteBudgetLimit(ctx _context.Context, id int32, limitId int32) ApiDeleteBudgetLimitRequest

	/*
	 * DeleteBudgetLimitExecute executes the request
	 */
	DeleteBudgetLimitExecute(r ApiDeleteBudgetLimitRequest) (*_nethttp.Response, error)

	/*
	 * GetBudget Get a single budget.
	 * Get a single budget. If the start date and end date are submitted as well, the "spent" array will be updated accordingly.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the requested budget.
	 * @return ApiGetBudgetRequest
	 */
	GetBudget(ctx _context.Context, id int32) ApiGetBudgetRequest

	/*
	 * GetBudgetExecute executes the request
	 * @return BudgetSingle
	 */
	GetBudgetExecute(r ApiGetBudgetRequest) (BudgetSingle, *_nethttp.Response, error)

	/*
	 * GetBudgetLimit Get single budget limit.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the budget. The budget limit MUST be associated to the budget ID.
	 * @param limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
	 * @return ApiGetBudgetLimitRequest
	 */
	GetBudgetLimit(ctx _context.Context, id int32, limitId int32) ApiGetBudgetLimitRequest

	/*
	 * GetBudgetLimitExecute executes the request
	 * @return BudgetLimitSingle
	 */
	GetBudgetLimitExecute(r ApiGetBudgetLimitRequest) (BudgetLimitSingle, *_nethttp.Response, error)

	/*
	 * ListAttachmentByBudget Lists all attachments of a budget.
	 * Lists all attachments.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the budget.
	 * @return ApiListAttachmentByBudgetRequest
	 */
	ListAttachmentByBudget(ctx _context.Context, id int32) ApiListAttachmentByBudgetRequest

	/*
	 * ListAttachmentByBudgetExecute executes the request
	 * @return AttachmentArray
	 */
	ListAttachmentByBudgetExecute(r ApiListAttachmentByBudgetRequest) (AttachmentArray, *_nethttp.Response, error)

	/*
	 * ListBudget List all budgets.
	 * List all the budgets the user has made. If the start date and end date are submitted as well, the "spent" array will be updated accordingly.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiListBudgetRequest
	 */
	ListBudget(ctx _context.Context) ApiListBudgetRequest

	/*
	 * ListBudgetExecute executes the request
	 * @return BudgetArray
	 */
	ListBudgetExecute(r ApiListBudgetRequest) (BudgetArray, *_nethttp.Response, error)

	/*
	 * ListBudgetLimit Get list of budget limits by date
	 * Get all budget limits for for this date range.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiListBudgetLimitRequest
	 */
	ListBudgetLimit(ctx _context.Context) ApiListBudgetLimitRequest

	/*
	 * ListBudgetLimitExecute executes the request
	 * @return BudgetLimitArray
	 */
	ListBudgetLimitExecute(r ApiListBudgetLimitRequest) (BudgetLimitArray, *_nethttp.Response, error)

	/*
	 * ListBudgetLimitByBudget Get all limits for a budget.
	 * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The "spent" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the requested budget.
	 * @return ApiListBudgetLimitByBudgetRequest
	 */
	ListBudgetLimitByBudget(ctx _context.Context, id int32) ApiListBudgetLimitByBudgetRequest

	/*
	 * ListBudgetLimitByBudgetExecute executes the request
	 * @return BudgetLimitArray
	 */
	ListBudgetLimitByBudgetExecute(r ApiListBudgetLimitByBudgetRequest) (BudgetLimitArray, *_nethttp.Response, error)

	/*
	 * ListTransactionByBudget All transactions to a budget.
	 * Get all transactions linked to a budget, possibly limited by start and end
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the budget.
	 * @return ApiListTransactionByBudgetRequest
	 */
	ListTransactionByBudget(ctx _context.Context, id int32) ApiListTransactionByBudgetRequest

	/*
	 * ListTransactionByBudgetExecute executes the request
	 * @return TransactionArray
	 */
	ListTransactionByBudgetExecute(r ApiListTransactionByBudgetRequest) (TransactionArray, *_nethttp.Response, error)

	/*
	 * ListTransactionByBudgetLimit List all transactions by a budget limit ID.
	 * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the budget. The budget limit MUST be associated to the budget ID.
	 * @param limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
	 * @return ApiListTransactionByBudgetLimitRequest
	 */
	ListTransactionByBudgetLimit(ctx _context.Context, id int32, limitId int32) ApiListTransactionByBudgetLimitRequest

	/*
	 * ListTransactionByBudgetLimitExecute executes the request
	 * @return TransactionArray
	 */
	ListTransactionByBudgetLimitExecute(r ApiListTransactionByBudgetLimitRequest) (TransactionArray, *_nethttp.Response, error)

	/*
	 * StoreBudget Store a new budget
	 * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiStoreBudgetRequest
	 */
	StoreBudget(ctx _context.Context) ApiStoreBudgetRequest

	/*
	 * StoreBudgetExecute executes the request
	 * @return BudgetSingle
	 */
	StoreBudgetExecute(r ApiStoreBudgetRequest) (BudgetSingle, *_nethttp.Response, error)

	/*
	 * StoreBudgetLimit Store new budget limit.
	 * Store a new budget limit under this budget.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the budget.
	 * @return ApiStoreBudgetLimitRequest
	 */
	StoreBudgetLimit(ctx _context.Context, id int32) ApiStoreBudgetLimitRequest

	/*
	 * StoreBudgetLimitExecute executes the request
	 * @return BudgetLimitSingle
	 */
	StoreBudgetLimitExecute(r ApiStoreBudgetLimitRequest) (BudgetLimitSingle, *_nethttp.Response, error)

	/*
	 * UpdateBudget Update existing budget.
	 * Update existing budget. This endpoint cannot be used to set budget amount limits.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the budget.
	 * @return ApiUpdateBudgetRequest
	 */
	UpdateBudget(ctx _context.Context, id int32) ApiUpdateBudgetRequest

	/*
	 * UpdateBudgetExecute executes the request
	 * @return BudgetSingle
	 */
	UpdateBudgetExecute(r ApiUpdateBudgetRequest) (BudgetSingle, *_nethttp.Response, error)

	/*
	 * UpdateBudgetLimit Update existing budget limit.
	 * Update existing budget limit.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the budget. The budget limit MUST be associated to the budget ID.
	 * @param limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
	 * @return ApiUpdateBudgetLimitRequest
	 */
	UpdateBudgetLimit(ctx _context.Context, id int32, limitId int32) ApiUpdateBudgetLimitRequest

	/*
	 * UpdateBudgetLimitExecute executes the request
	 * @return BudgetLimitSingle
	 */
	UpdateBudgetLimitExecute(r ApiUpdateBudgetLimitRequest) (BudgetLimitSingle, *_nethttp.Response, error)
}

// BudgetsApiService BudgetsApi service
type BudgetsApiService service

type ApiDeleteBudgetRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
}


func (r ApiDeleteBudgetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteBudgetExecute(r)
}

/*
 * DeleteBudget Delete a budget.
 * Delete a budget. Transactions will not be deleted.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the budget.
 * @return ApiDeleteBudgetRequest
 */
func (a *BudgetsApiService) DeleteBudget(ctx _context.Context, id int32) ApiDeleteBudgetRequest {
	return ApiDeleteBudgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *BudgetsApiService) DeleteBudgetExecute(r ApiDeleteBudgetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.DeleteBudget")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id < 1 {
		return nil, reportError("id must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBudgetLimitRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	limitId int32
}


func (r ApiDeleteBudgetLimitRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteBudgetLimitExecute(r)
}

/*
 * DeleteBudgetLimit Delete a budget limit.
 * Delete a budget limit.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the budget. The budget limit MUST be associated to the budget ID.
 * @param limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
 * @return ApiDeleteBudgetLimitRequest
 */
func (a *BudgetsApiService) DeleteBudgetLimit(ctx _context.Context, id int32, limitId int32) ApiDeleteBudgetLimitRequest {
	return ApiDeleteBudgetLimitRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		limitId: limitId,
	}
}

/*
 * Execute executes the request
 */
func (a *BudgetsApiService) DeleteBudgetLimitExecute(r ApiDeleteBudgetLimitRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.DeleteBudgetLimit")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}/limits/{limitId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"limitId"+"}", _neturl.PathEscape(parameterToString(r.limitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id < 1 {
		return nil, reportError("id must be greater than 1")
	}
	if r.limitId < 1 {
		return nil, reportError("limitId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBudgetRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	start *string
	end *string
}

func (r ApiGetBudgetRequest) Start(start string) ApiGetBudgetRequest {
	r.start = &start
	return r
}
func (r ApiGetBudgetRequest) End(end string) ApiGetBudgetRequest {
	r.end = &end
	return r
}

func (r ApiGetBudgetRequest) Execute() (BudgetSingle, *_nethttp.Response, error) {
	return r.ApiService.GetBudgetExecute(r)
}

/*
 * GetBudget Get a single budget.
 * Get a single budget. If the start date and end date are submitted as well, the "spent" array will be updated accordingly.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the requested budget.
 * @return ApiGetBudgetRequest
 */
func (a *BudgetsApiService) GetBudget(ctx _context.Context, id int32) ApiGetBudgetRequest {
	return ApiGetBudgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BudgetSingle
 */
func (a *BudgetsApiService) GetBudgetExecute(r ApiGetBudgetRequest) (BudgetSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.GetBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBudgetLimitRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	limitId int32
}


func (r ApiGetBudgetLimitRequest) Execute() (BudgetLimitSingle, *_nethttp.Response, error) {
	return r.ApiService.GetBudgetLimitExecute(r)
}

/*
 * GetBudgetLimit Get single budget limit.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the budget. The budget limit MUST be associated to the budget ID.
 * @param limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
 * @return ApiGetBudgetLimitRequest
 */
func (a *BudgetsApiService) GetBudgetLimit(ctx _context.Context, id int32, limitId int32) ApiGetBudgetLimitRequest {
	return ApiGetBudgetLimitRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		limitId: limitId,
	}
}

/*
 * Execute executes the request
 * @return BudgetLimitSingle
 */
func (a *BudgetsApiService) GetBudgetLimitExecute(r ApiGetBudgetLimitRequest) (BudgetLimitSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetLimitSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.GetBudgetLimit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}/limits/{limitId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"limitId"+"}", _neturl.PathEscape(parameterToString(r.limitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.limitId < 1 {
		return localVarReturnValue, nil, reportError("limitId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAttachmentByBudgetRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	page *int32
}

func (r ApiListAttachmentByBudgetRequest) Page(page int32) ApiListAttachmentByBudgetRequest {
	r.page = &page
	return r
}

func (r ApiListAttachmentByBudgetRequest) Execute() (AttachmentArray, *_nethttp.Response, error) {
	return r.ApiService.ListAttachmentByBudgetExecute(r)
}

/*
 * ListAttachmentByBudget Lists all attachments of a budget.
 * Lists all attachments.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the budget.
 * @return ApiListAttachmentByBudgetRequest
 */
func (a *BudgetsApiService) ListAttachmentByBudget(ctx _context.Context, id int32) ApiListAttachmentByBudgetRequest {
	return ApiListAttachmentByBudgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AttachmentArray
 */
func (a *BudgetsApiService) ListAttachmentByBudgetExecute(r ApiListAttachmentByBudgetRequest) (AttachmentArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttachmentArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.ListAttachmentByBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBudgetRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	page *int32
	start *string
	end *string
}

func (r ApiListBudgetRequest) Page(page int32) ApiListBudgetRequest {
	r.page = &page
	return r
}
func (r ApiListBudgetRequest) Start(start string) ApiListBudgetRequest {
	r.start = &start
	return r
}
func (r ApiListBudgetRequest) End(end string) ApiListBudgetRequest {
	r.end = &end
	return r
}

func (r ApiListBudgetRequest) Execute() (BudgetArray, *_nethttp.Response, error) {
	return r.ApiService.ListBudgetExecute(r)
}

/*
 * ListBudget List all budgets.
 * List all the budgets the user has made. If the start date and end date are submitted as well, the "spent" array will be updated accordingly.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListBudgetRequest
 */
func (a *BudgetsApiService) ListBudget(ctx _context.Context) ApiListBudgetRequest {
	return ApiListBudgetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return BudgetArray
 */
func (a *BudgetsApiService) ListBudgetExecute(r ApiListBudgetRequest) (BudgetArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.ListBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBudgetLimitRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	start *string
	end *string
}

func (r ApiListBudgetLimitRequest) Start(start string) ApiListBudgetLimitRequest {
	r.start = &start
	return r
}
func (r ApiListBudgetLimitRequest) End(end string) ApiListBudgetLimitRequest {
	r.end = &end
	return r
}

func (r ApiListBudgetLimitRequest) Execute() (BudgetLimitArray, *_nethttp.Response, error) {
	return r.ApiService.ListBudgetLimitExecute(r)
}

/*
 * ListBudgetLimit Get list of budget limits by date
 * Get all budget limits for for this date range.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListBudgetLimitRequest
 */
func (a *BudgetsApiService) ListBudgetLimit(ctx _context.Context) ApiListBudgetLimitRequest {
	return ApiListBudgetLimitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return BudgetLimitArray
 */
func (a *BudgetsApiService) ListBudgetLimitExecute(r ApiListBudgetLimitRequest) (BudgetLimitArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetLimitArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.ListBudgetLimit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budget-limits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBudgetLimitByBudgetRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	start *string
	end *string
}

func (r ApiListBudgetLimitByBudgetRequest) Start(start string) ApiListBudgetLimitByBudgetRequest {
	r.start = &start
	return r
}
func (r ApiListBudgetLimitByBudgetRequest) End(end string) ApiListBudgetLimitByBudgetRequest {
	r.end = &end
	return r
}

func (r ApiListBudgetLimitByBudgetRequest) Execute() (BudgetLimitArray, *_nethttp.Response, error) {
	return r.ApiService.ListBudgetLimitByBudgetExecute(r)
}

/*
 * ListBudgetLimitByBudget Get all limits for a budget.
 * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The "spent" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the requested budget.
 * @return ApiListBudgetLimitByBudgetRequest
 */
func (a *BudgetsApiService) ListBudgetLimitByBudget(ctx _context.Context, id int32) ApiListBudgetLimitByBudgetRequest {
	return ApiListBudgetLimitByBudgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BudgetLimitArray
 */
func (a *BudgetsApiService) ListBudgetLimitByBudgetExecute(r ApiListBudgetLimitByBudgetRequest) (BudgetLimitArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetLimitArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.ListBudgetLimitByBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}/limits"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}

	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionByBudgetRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	limit *int32
	page *int32
	start *string
	end *string
	type_ *TransactionTypeFilter
}

func (r ApiListTransactionByBudgetRequest) Limit(limit int32) ApiListTransactionByBudgetRequest {
	r.limit = &limit
	return r
}
func (r ApiListTransactionByBudgetRequest) Page(page int32) ApiListTransactionByBudgetRequest {
	r.page = &page
	return r
}
func (r ApiListTransactionByBudgetRequest) Start(start string) ApiListTransactionByBudgetRequest {
	r.start = &start
	return r
}
func (r ApiListTransactionByBudgetRequest) End(end string) ApiListTransactionByBudgetRequest {
	r.end = &end
	return r
}
func (r ApiListTransactionByBudgetRequest) Type_(type_ TransactionTypeFilter) ApiListTransactionByBudgetRequest {
	r.type_ = &type_
	return r
}

func (r ApiListTransactionByBudgetRequest) Execute() (TransactionArray, *_nethttp.Response, error) {
	return r.ApiService.ListTransactionByBudgetExecute(r)
}

/*
 * ListTransactionByBudget All transactions to a budget.
 * Get all transactions linked to a budget, possibly limited by start and end
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the budget.
 * @return ApiListTransactionByBudgetRequest
 */
func (a *BudgetsApiService) ListTransactionByBudget(ctx _context.Context, id int32) ApiListTransactionByBudgetRequest {
	return ApiListTransactionByBudgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return TransactionArray
 */
func (a *BudgetsApiService) ListTransactionByBudgetExecute(r ApiListTransactionByBudgetRequest) (TransactionArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TransactionArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.ListTransactionByBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionByBudgetLimitRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	limitId int32
	page *int32
	type_ *TransactionTypeFilter
}

func (r ApiListTransactionByBudgetLimitRequest) Page(page int32) ApiListTransactionByBudgetLimitRequest {
	r.page = &page
	return r
}
func (r ApiListTransactionByBudgetLimitRequest) Type_(type_ TransactionTypeFilter) ApiListTransactionByBudgetLimitRequest {
	r.type_ = &type_
	return r
}

func (r ApiListTransactionByBudgetLimitRequest) Execute() (TransactionArray, *_nethttp.Response, error) {
	return r.ApiService.ListTransactionByBudgetLimitExecute(r)
}

/*
 * ListTransactionByBudgetLimit List all transactions by a budget limit ID.
 * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the budget. The budget limit MUST be associated to the budget ID.
 * @param limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
 * @return ApiListTransactionByBudgetLimitRequest
 */
func (a *BudgetsApiService) ListTransactionByBudgetLimit(ctx _context.Context, id int32, limitId int32) ApiListTransactionByBudgetLimitRequest {
	return ApiListTransactionByBudgetLimitRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		limitId: limitId,
	}
}

/*
 * Execute executes the request
 * @return TransactionArray
 */
func (a *BudgetsApiService) ListTransactionByBudgetLimitExecute(r ApiListTransactionByBudgetLimitRequest) (TransactionArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TransactionArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.ListTransactionByBudgetLimit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}/limits/{limitId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"limitId"+"}", _neturl.PathEscape(parameterToString(r.limitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.limitId < 1 {
		return localVarReturnValue, nil, reportError("limitId must be greater than 1")
	}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStoreBudgetRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	budgetStore *BudgetStore
}

func (r ApiStoreBudgetRequest) BudgetStore(budgetStore BudgetStore) ApiStoreBudgetRequest {
	r.budgetStore = &budgetStore
	return r
}

func (r ApiStoreBudgetRequest) Execute() (BudgetSingle, *_nethttp.Response, error) {
	return r.ApiService.StoreBudgetExecute(r)
}

/*
 * StoreBudget Store a new budget
 * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiStoreBudgetRequest
 */
func (a *BudgetsApiService) StoreBudget(ctx _context.Context) ApiStoreBudgetRequest {
	return ApiStoreBudgetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return BudgetSingle
 */
func (a *BudgetsApiService) StoreBudgetExecute(r ApiStoreBudgetRequest) (BudgetSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.StoreBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.budgetStore == nil {
		return localVarReturnValue, nil, reportError("budgetStore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.budgetStore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStoreBudgetLimitRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	budgetLimitStore *BudgetLimitStore
}

func (r ApiStoreBudgetLimitRequest) BudgetLimitStore(budgetLimitStore BudgetLimitStore) ApiStoreBudgetLimitRequest {
	r.budgetLimitStore = &budgetLimitStore
	return r
}

func (r ApiStoreBudgetLimitRequest) Execute() (BudgetLimitSingle, *_nethttp.Response, error) {
	return r.ApiService.StoreBudgetLimitExecute(r)
}

/*
 * StoreBudgetLimit Store new budget limit.
 * Store a new budget limit under this budget.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the budget.
 * @return ApiStoreBudgetLimitRequest
 */
func (a *BudgetsApiService) StoreBudgetLimit(ctx _context.Context, id int32) ApiStoreBudgetLimitRequest {
	return ApiStoreBudgetLimitRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BudgetLimitSingle
 */
func (a *BudgetsApiService) StoreBudgetLimitExecute(r ApiStoreBudgetLimitRequest) (BudgetLimitSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetLimitSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.StoreBudgetLimit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}/limits"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.budgetLimitStore == nil {
		return localVarReturnValue, nil, reportError("budgetLimitStore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.budgetLimitStore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBudgetRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	budgetUpdate *BudgetUpdate
}

func (r ApiUpdateBudgetRequest) BudgetUpdate(budgetUpdate BudgetUpdate) ApiUpdateBudgetRequest {
	r.budgetUpdate = &budgetUpdate
	return r
}

func (r ApiUpdateBudgetRequest) Execute() (BudgetSingle, *_nethttp.Response, error) {
	return r.ApiService.UpdateBudgetExecute(r)
}

/*
 * UpdateBudget Update existing budget.
 * Update existing budget. This endpoint cannot be used to set budget amount limits.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the budget.
 * @return ApiUpdateBudgetRequest
 */
func (a *BudgetsApiService) UpdateBudget(ctx _context.Context, id int32) ApiUpdateBudgetRequest {
	return ApiUpdateBudgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BudgetSingle
 */
func (a *BudgetsApiService) UpdateBudgetExecute(r ApiUpdateBudgetRequest) (BudgetSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.UpdateBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.budgetUpdate == nil {
		return localVarReturnValue, nil, reportError("budgetUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.budgetUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBudgetLimitRequest struct {
	ctx _context.Context
	ApiService BudgetsApi
	id int32
	limitId int32
	budgetLimit *BudgetLimit
}

func (r ApiUpdateBudgetLimitRequest) BudgetLimit(budgetLimit BudgetLimit) ApiUpdateBudgetLimitRequest {
	r.budgetLimit = &budgetLimit
	return r
}

func (r ApiUpdateBudgetLimitRequest) Execute() (BudgetLimitSingle, *_nethttp.Response, error) {
	return r.ApiService.UpdateBudgetLimitExecute(r)
}

/*
 * UpdateBudgetLimit Update existing budget limit.
 * Update existing budget limit.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the budget. The budget limit MUST be associated to the budget ID.
 * @param limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
 * @return ApiUpdateBudgetLimitRequest
 */
func (a *BudgetsApiService) UpdateBudgetLimit(ctx _context.Context, id int32, limitId int32) ApiUpdateBudgetLimitRequest {
	return ApiUpdateBudgetLimitRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		limitId: limitId,
	}
}

/*
 * Execute executes the request
 * @return BudgetLimitSingle
 */
func (a *BudgetsApiService) UpdateBudgetLimitExecute(r ApiUpdateBudgetLimitRequest) (BudgetLimitSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetLimitSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.UpdateBudgetLimit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/budgets/{id}/limits/{limitId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"limitId"+"}", _neturl.PathEscape(parameterToString(r.limitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.limitId < 1 {
		return localVarReturnValue, nil, reportError("limitId must be greater than 1")
	}
	if r.budgetLimit == nil {
		return localVarReturnValue, nil, reportError("budgetLimit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.budgetLimit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
