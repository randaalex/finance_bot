/*
 * Firefly III API v1.5.2
 *
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2021-05-14T15:49:56+00:00 
 *
 * API version: 1.5.2
 * Contact: james@firefly-iii.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package firefly

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type AvailableBudgetsApi interface {

	/*
	 * DeleteAvailableBudget Delete an available budget.
	 * Delete an available budget. Not much more to say.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the available budget.
	 * @return ApiDeleteAvailableBudgetRequest
	 */
	DeleteAvailableBudget(ctx _context.Context, id int32) ApiDeleteAvailableBudgetRequest

	/*
	 * DeleteAvailableBudgetExecute executes the request
	 */
	DeleteAvailableBudgetExecute(r ApiDeleteAvailableBudgetRequest) (*_nethttp.Response, error)

	/*
	 * GetAvailableBudget Get a single available budget.
	 * Get a single available budget, by ID.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the available budget.
	 * @return ApiGetAvailableBudgetRequest
	 */
	GetAvailableBudget(ctx _context.Context, id int32) ApiGetAvailableBudgetRequest

	/*
	 * GetAvailableBudgetExecute executes the request
	 * @return AvailableBudgetSingle
	 */
	GetAvailableBudgetExecute(r ApiGetAvailableBudgetRequest) (AvailableBudgetSingle, *_nethttp.Response, error)

	/*
	 * ListAvailableBudget List all available budget amounts.
	 * Firefly III allows users to set the amount that is available to be budgeted in so-called "available budgets". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiListAvailableBudgetRequest
	 */
	ListAvailableBudget(ctx _context.Context) ApiListAvailableBudgetRequest

	/*
	 * ListAvailableBudgetExecute executes the request
	 * @return AvailableBudgetArray
	 */
	ListAvailableBudgetExecute(r ApiListAvailableBudgetRequest) (AvailableBudgetArray, *_nethttp.Response, error)

	/*
	 * StoreAvailableBudget Store a new available budget
	 * Creates a new available budget for a specified period. The data required can be submitted as a JSON body or as a list of parameters.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiStoreAvailableBudgetRequest
	 */
	StoreAvailableBudget(ctx _context.Context) ApiStoreAvailableBudgetRequest

	/*
	 * StoreAvailableBudgetExecute executes the request
	 * @return AvailableBudgetSingle
	 */
	StoreAvailableBudgetExecute(r ApiStoreAvailableBudgetRequest) (AvailableBudgetSingle, *_nethttp.Response, error)

	/*
	 * UpdateAvailableBudget Update existing available budget, to change for example the date range of the amount or the amount itself.
	 * Update existing available budget.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param id The ID of the object.X
	 * @return ApiUpdateAvailableBudgetRequest
	 */
	UpdateAvailableBudget(ctx _context.Context, id int32) ApiUpdateAvailableBudgetRequest

	/*
	 * UpdateAvailableBudgetExecute executes the request
	 * @return AvailableBudgetSingle
	 */
	UpdateAvailableBudgetExecute(r ApiUpdateAvailableBudgetRequest) (AvailableBudgetSingle, *_nethttp.Response, error)
}

// AvailableBudgetsApiService AvailableBudgetsApi service
type AvailableBudgetsApiService service

type ApiDeleteAvailableBudgetRequest struct {
	ctx _context.Context
	ApiService AvailableBudgetsApi
	id int32
}


func (r ApiDeleteAvailableBudgetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAvailableBudgetExecute(r)
}

/*
 * DeleteAvailableBudget Delete an available budget.
 * Delete an available budget. Not much more to say.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the available budget.
 * @return ApiDeleteAvailableBudgetRequest
 */
func (a *AvailableBudgetsApiService) DeleteAvailableBudget(ctx _context.Context, id int32) ApiDeleteAvailableBudgetRequest {
	return ApiDeleteAvailableBudgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AvailableBudgetsApiService) DeleteAvailableBudgetExecute(r ApiDeleteAvailableBudgetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailableBudgetsApiService.DeleteAvailableBudget")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/available_budgets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAvailableBudgetRequest struct {
	ctx _context.Context
	ApiService AvailableBudgetsApi
	id int32
}


func (r ApiGetAvailableBudgetRequest) Execute() (AvailableBudgetSingle, *_nethttp.Response, error) {
	return r.ApiService.GetAvailableBudgetExecute(r)
}

/*
 * GetAvailableBudget Get a single available budget.
 * Get a single available budget, by ID.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the available budget.
 * @return ApiGetAvailableBudgetRequest
 */
func (a *AvailableBudgetsApiService) GetAvailableBudget(ctx _context.Context, id int32) ApiGetAvailableBudgetRequest {
	return ApiGetAvailableBudgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AvailableBudgetSingle
 */
func (a *AvailableBudgetsApiService) GetAvailableBudgetExecute(r ApiGetAvailableBudgetRequest) (AvailableBudgetSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AvailableBudgetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailableBudgetsApiService.GetAvailableBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/available_budgets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailableBudgetRequest struct {
	ctx _context.Context
	ApiService AvailableBudgetsApi
	page *int32
	start *string
	end *string
}

func (r ApiListAvailableBudgetRequest) Page(page int32) ApiListAvailableBudgetRequest {
	r.page = &page
	return r
}
func (r ApiListAvailableBudgetRequest) Start(start string) ApiListAvailableBudgetRequest {
	r.start = &start
	return r
}
func (r ApiListAvailableBudgetRequest) End(end string) ApiListAvailableBudgetRequest {
	r.end = &end
	return r
}

func (r ApiListAvailableBudgetRequest) Execute() (AvailableBudgetArray, *_nethttp.Response, error) {
	return r.ApiService.ListAvailableBudgetExecute(r)
}

/*
 * ListAvailableBudget List all available budget amounts.
 * Firefly III allows users to set the amount that is available to be budgeted in so-called "available budgets". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListAvailableBudgetRequest
 */
func (a *AvailableBudgetsApiService) ListAvailableBudget(ctx _context.Context) ApiListAvailableBudgetRequest {
	return ApiListAvailableBudgetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AvailableBudgetArray
 */
func (a *AvailableBudgetsApiService) ListAvailableBudgetExecute(r ApiListAvailableBudgetRequest) (AvailableBudgetArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AvailableBudgetArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailableBudgetsApiService.ListAvailableBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/available_budgets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStoreAvailableBudgetRequest struct {
	ctx _context.Context
	ApiService AvailableBudgetsApi
	availableBudgetStore *AvailableBudgetStore
}

func (r ApiStoreAvailableBudgetRequest) AvailableBudgetStore(availableBudgetStore AvailableBudgetStore) ApiStoreAvailableBudgetRequest {
	r.availableBudgetStore = &availableBudgetStore
	return r
}

func (r ApiStoreAvailableBudgetRequest) Execute() (AvailableBudgetSingle, *_nethttp.Response, error) {
	return r.ApiService.StoreAvailableBudgetExecute(r)
}

/*
 * StoreAvailableBudget Store a new available budget
 * Creates a new available budget for a specified period. The data required can be submitted as a JSON body or as a list of parameters.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiStoreAvailableBudgetRequest
 */
func (a *AvailableBudgetsApiService) StoreAvailableBudget(ctx _context.Context) ApiStoreAvailableBudgetRequest {
	return ApiStoreAvailableBudgetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AvailableBudgetSingle
 */
func (a *AvailableBudgetsApiService) StoreAvailableBudgetExecute(r ApiStoreAvailableBudgetRequest) (AvailableBudgetSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AvailableBudgetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailableBudgetsApiService.StoreAvailableBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/available_budgets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.availableBudgetStore == nil {
		return localVarReturnValue, nil, reportError("availableBudgetStore is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.availableBudgetStore
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAvailableBudgetRequest struct {
	ctx _context.Context
	ApiService AvailableBudgetsApi
	id int32
	availableBudgetUpdate *AvailableBudgetUpdate
}

func (r ApiUpdateAvailableBudgetRequest) AvailableBudgetUpdate(availableBudgetUpdate AvailableBudgetUpdate) ApiUpdateAvailableBudgetRequest {
	r.availableBudgetUpdate = &availableBudgetUpdate
	return r
}

func (r ApiUpdateAvailableBudgetRequest) Execute() (AvailableBudgetSingle, *_nethttp.Response, error) {
	return r.ApiService.UpdateAvailableBudgetExecute(r)
}

/*
 * UpdateAvailableBudget Update existing available budget, to change for example the date range of the amount or the amount itself.
 * Update existing available budget.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the object.X
 * @return ApiUpdateAvailableBudgetRequest
 */
func (a *AvailableBudgetsApiService) UpdateAvailableBudget(ctx _context.Context, id int32) ApiUpdateAvailableBudgetRequest {
	return ApiUpdateAvailableBudgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AvailableBudgetSingle
 */
func (a *AvailableBudgetsApiService) UpdateAvailableBudgetExecute(r ApiUpdateAvailableBudgetRequest) (AvailableBudgetSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AvailableBudgetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AvailableBudgetsApiService.UpdateAvailableBudget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/available_budgets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.availableBudgetUpdate == nil {
		return localVarReturnValue, nil, reportError("availableBudgetUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.api+json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.api+json", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.availableBudgetUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
