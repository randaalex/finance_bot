/*
 * Firefly III API
 *
 * This is the official documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. This version of the API is live from version v4.7.9 and onwards. You may use the \"Authorize\" button to try the API below. 
 *
 * API version: 1.4.0
 * Contact: james@firefly-iii.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package firefly

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

type AutocompleteApi interface {

	/*
	 * GetAccountsAC All accounts of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetAccountsACRequest
	 */
	GetAccountsAC(ctx _context.Context) ApiGetAccountsACRequest

	/*
	 * GetAccountsACExecute executes the request
	 * @return []AutocompleteAccount
	 */
	GetAccountsACExecute(r ApiGetAccountsACRequest) ([]AutocompleteAccount, *_nethttp.Response, error)

	/*
	 * GetBillsAC All bills of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetBillsACRequest
	 */
	GetBillsAC(ctx _context.Context) ApiGetBillsACRequest

	/*
	 * GetBillsACExecute executes the request
	 * @return []AutocompleteBill
	 */
	GetBillsACExecute(r ApiGetBillsACRequest) ([]AutocompleteBill, *_nethttp.Response, error)

	/*
	 * GetBudgetsAC All budgets of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetBudgetsACRequest
	 */
	GetBudgetsAC(ctx _context.Context) ApiGetBudgetsACRequest

	/*
	 * GetBudgetsACExecute executes the request
	 * @return []AutocompleteBudget
	 */
	GetBudgetsACExecute(r ApiGetBudgetsACRequest) ([]AutocompleteBudget, *_nethttp.Response, error)

	/*
	 * GetCategoriesAC All categories of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetCategoriesACRequest
	 */
	GetCategoriesAC(ctx _context.Context) ApiGetCategoriesACRequest

	/*
	 * GetCategoriesACExecute executes the request
	 * @return []AutocompleteCategory
	 */
	GetCategoriesACExecute(r ApiGetCategoriesACRequest) ([]AutocompleteCategory, *_nethttp.Response, error)

	/*
	 * GetCurrenciesAC All currencies of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetCurrenciesACRequest
	 */
	GetCurrenciesAC(ctx _context.Context) ApiGetCurrenciesACRequest

	/*
	 * GetCurrenciesACExecute executes the request
	 * @return []AutocompleteCurrency
	 */
	GetCurrenciesACExecute(r ApiGetCurrenciesACRequest) ([]AutocompleteCurrency, *_nethttp.Response, error)

	/*
	 * GetCurrenciesCodeAC All currencies of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetCurrenciesCodeACRequest
	 */
	GetCurrenciesCodeAC(ctx _context.Context) ApiGetCurrenciesCodeACRequest

	/*
	 * GetCurrenciesCodeACExecute executes the request
	 * @return []AutocompleteCurrencyCode
	 */
	GetCurrenciesCodeACExecute(r ApiGetCurrenciesCodeACRequest) ([]AutocompleteCurrencyCode, *_nethttp.Response, error)

	/*
	 * GetObjectGroupsAC All object groups of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetObjectGroupsACRequest
	 */
	GetObjectGroupsAC(ctx _context.Context) ApiGetObjectGroupsACRequest

	/*
	 * GetObjectGroupsACExecute executes the request
	 * @return []AutocompleteObjectGroup
	 */
	GetObjectGroupsACExecute(r ApiGetObjectGroupsACRequest) ([]AutocompleteObjectGroup, *_nethttp.Response, error)

	/*
	 * GetPiggiesAC All piggy banks of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetPiggiesACRequest
	 */
	GetPiggiesAC(ctx _context.Context) ApiGetPiggiesACRequest

	/*
	 * GetPiggiesACExecute executes the request
	 * @return []AutocompletePiggy
	 */
	GetPiggiesACExecute(r ApiGetPiggiesACRequest) ([]AutocompletePiggy, *_nethttp.Response, error)

	/*
	 * GetPiggiesBalanceAC All piggy banks of the user returned in a basic auto-complete array complemented with balance information.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetPiggiesBalanceACRequest
	 */
	GetPiggiesBalanceAC(ctx _context.Context) ApiGetPiggiesBalanceACRequest

	/*
	 * GetPiggiesBalanceACExecute executes the request
	 * @return []AutocompletePiggyBalance
	 */
	GetPiggiesBalanceACExecute(r ApiGetPiggiesBalanceACRequest) ([]AutocompletePiggyBalance, *_nethttp.Response, error)

	/*
	 * GetRuleGroupsAC All rule groups of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetRuleGroupsACRequest
	 */
	GetRuleGroupsAC(ctx _context.Context) ApiGetRuleGroupsACRequest

	/*
	 * GetRuleGroupsACExecute executes the request
	 * @return []AutocompleteRuleGroup
	 */
	GetRuleGroupsACExecute(r ApiGetRuleGroupsACRequest) ([]AutocompleteRuleGroup, *_nethttp.Response, error)

	/*
	 * GetRulesAC All rules of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetRulesACRequest
	 */
	GetRulesAC(ctx _context.Context) ApiGetRulesACRequest

	/*
	 * GetRulesACExecute executes the request
	 * @return []AutocompleteRule
	 */
	GetRulesACExecute(r ApiGetRulesACRequest) ([]AutocompleteRule, *_nethttp.Response, error)

	/*
	 * GetTagAC All tags of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetTagACRequest
	 */
	GetTagAC(ctx _context.Context) ApiGetTagACRequest

	/*
	 * GetTagACExecute executes the request
	 * @return []AutocompleteTag
	 */
	GetTagACExecute(r ApiGetTagACRequest) ([]AutocompleteTag, *_nethttp.Response, error)

	/*
	 * GetTransactionTypesAC All transaction types returned in a basic auto-complete array. English only.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetTransactionTypesACRequest
	 */
	GetTransactionTypesAC(ctx _context.Context) ApiGetTransactionTypesACRequest

	/*
	 * GetTransactionTypesACExecute executes the request
	 * @return []AutocompleteTransactionType
	 */
	GetTransactionTypesACExecute(r ApiGetTransactionTypesACRequest) ([]AutocompleteTransactionType, *_nethttp.Response, error)

	/*
	 * GetTransactionsAC All transaction descriptions of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetTransactionsACRequest
	 */
	GetTransactionsAC(ctx _context.Context) ApiGetTransactionsACRequest

	/*
	 * GetTransactionsACExecute executes the request
	 * @return []AutocompleteTransaction
	 */
	GetTransactionsACExecute(r ApiGetTransactionsACRequest) ([]AutocompleteTransaction, *_nethttp.Response, error)

	/*
	 * GetTransactionsIDAC All transactions, complemented with their ID, of the user returned in a basic auto-complete array.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiGetTransactionsIDACRequest
	 */
	GetTransactionsIDAC(ctx _context.Context) ApiGetTransactionsIDACRequest

	/*
	 * GetTransactionsIDACExecute executes the request
	 * @return []AutocompleteTransactionID
	 */
	GetTransactionsIDACExecute(r ApiGetTransactionsIDACRequest) ([]AutocompleteTransactionID, *_nethttp.Response, error)
}

// AutocompleteApiService AutocompleteApi service
type AutocompleteApiService service

type ApiGetAccountsACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
	date *string
	type_ *AccountTypeFilter
}

func (r ApiGetAccountsACRequest) Query(query string) ApiGetAccountsACRequest {
	r.query = &query
	return r
}
func (r ApiGetAccountsACRequest) Limit(limit int32) ApiGetAccountsACRequest {
	r.limit = &limit
	return r
}
func (r ApiGetAccountsACRequest) Date(date string) ApiGetAccountsACRequest {
	r.date = &date
	return r
}
func (r ApiGetAccountsACRequest) Type_(type_ AccountTypeFilter) ApiGetAccountsACRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetAccountsACRequest) Execute() ([]AutocompleteAccount, *_nethttp.Response, error) {
	return r.ApiService.GetAccountsACExecute(r)
}

/*
 * GetAccountsAC All accounts of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAccountsACRequest
 */
func (a *AutocompleteApiService) GetAccountsAC(ctx _context.Context) ApiGetAccountsACRequest {
	return ApiGetAccountsACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteAccount
 */
func (a *AutocompleteApiService) GetAccountsACExecute(r ApiGetAccountsACRequest) ([]AutocompleteAccount, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetAccountsAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.date != nil {
		localVarQueryParams.Add("date", parameterToString(*r.date, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillsACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetBillsACRequest) Query(query string) ApiGetBillsACRequest {
	r.query = &query
	return r
}
func (r ApiGetBillsACRequest) Limit(limit int32) ApiGetBillsACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBillsACRequest) Execute() ([]AutocompleteBill, *_nethttp.Response, error) {
	return r.ApiService.GetBillsACExecute(r)
}

/*
 * GetBillsAC All bills of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetBillsACRequest
 */
func (a *AutocompleteApiService) GetBillsAC(ctx _context.Context) ApiGetBillsACRequest {
	return ApiGetBillsACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteBill
 */
func (a *AutocompleteApiService) GetBillsACExecute(r ApiGetBillsACRequest) ([]AutocompleteBill, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteBill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetBillsAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/bills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBudgetsACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetBudgetsACRequest) Query(query string) ApiGetBudgetsACRequest {
	r.query = &query
	return r
}
func (r ApiGetBudgetsACRequest) Limit(limit int32) ApiGetBudgetsACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBudgetsACRequest) Execute() ([]AutocompleteBudget, *_nethttp.Response, error) {
	return r.ApiService.GetBudgetsACExecute(r)
}

/*
 * GetBudgetsAC All budgets of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetBudgetsACRequest
 */
func (a *AutocompleteApiService) GetBudgetsAC(ctx _context.Context) ApiGetBudgetsACRequest {
	return ApiGetBudgetsACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteBudget
 */
func (a *AutocompleteApiService) GetBudgetsACExecute(r ApiGetBudgetsACRequest) ([]AutocompleteBudget, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteBudget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetBudgetsAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/budgets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoriesACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetCategoriesACRequest) Query(query string) ApiGetCategoriesACRequest {
	r.query = &query
	return r
}
func (r ApiGetCategoriesACRequest) Limit(limit int32) ApiGetCategoriesACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCategoriesACRequest) Execute() ([]AutocompleteCategory, *_nethttp.Response, error) {
	return r.ApiService.GetCategoriesACExecute(r)
}

/*
 * GetCategoriesAC All categories of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCategoriesACRequest
 */
func (a *AutocompleteApiService) GetCategoriesAC(ctx _context.Context) ApiGetCategoriesACRequest {
	return ApiGetCategoriesACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteCategory
 */
func (a *AutocompleteApiService) GetCategoriesACExecute(r ApiGetCategoriesACRequest) ([]AutocompleteCategory, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetCategoriesAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrenciesACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetCurrenciesACRequest) Query(query string) ApiGetCurrenciesACRequest {
	r.query = &query
	return r
}
func (r ApiGetCurrenciesACRequest) Limit(limit int32) ApiGetCurrenciesACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCurrenciesACRequest) Execute() ([]AutocompleteCurrency, *_nethttp.Response, error) {
	return r.ApiService.GetCurrenciesACExecute(r)
}

/*
 * GetCurrenciesAC All currencies of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCurrenciesACRequest
 */
func (a *AutocompleteApiService) GetCurrenciesAC(ctx _context.Context) ApiGetCurrenciesACRequest {
	return ApiGetCurrenciesACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteCurrency
 */
func (a *AutocompleteApiService) GetCurrenciesACExecute(r ApiGetCurrenciesACRequest) ([]AutocompleteCurrency, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteCurrency
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetCurrenciesAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrenciesCodeACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetCurrenciesCodeACRequest) Query(query string) ApiGetCurrenciesCodeACRequest {
	r.query = &query
	return r
}
func (r ApiGetCurrenciesCodeACRequest) Limit(limit int32) ApiGetCurrenciesCodeACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCurrenciesCodeACRequest) Execute() ([]AutocompleteCurrencyCode, *_nethttp.Response, error) {
	return r.ApiService.GetCurrenciesCodeACExecute(r)
}

/*
 * GetCurrenciesCodeAC All currencies of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCurrenciesCodeACRequest
 */
func (a *AutocompleteApiService) GetCurrenciesCodeAC(ctx _context.Context) ApiGetCurrenciesCodeACRequest {
	return ApiGetCurrenciesCodeACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteCurrencyCode
 */
func (a *AutocompleteApiService) GetCurrenciesCodeACExecute(r ApiGetCurrenciesCodeACRequest) ([]AutocompleteCurrencyCode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteCurrencyCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetCurrenciesCodeAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/currencies-with-code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectGroupsACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetObjectGroupsACRequest) Query(query string) ApiGetObjectGroupsACRequest {
	r.query = &query
	return r
}
func (r ApiGetObjectGroupsACRequest) Limit(limit int32) ApiGetObjectGroupsACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetObjectGroupsACRequest) Execute() ([]AutocompleteObjectGroup, *_nethttp.Response, error) {
	return r.ApiService.GetObjectGroupsACExecute(r)
}

/*
 * GetObjectGroupsAC All object groups of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetObjectGroupsACRequest
 */
func (a *AutocompleteApiService) GetObjectGroupsAC(ctx _context.Context) ApiGetObjectGroupsACRequest {
	return ApiGetObjectGroupsACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteObjectGroup
 */
func (a *AutocompleteApiService) GetObjectGroupsACExecute(r ApiGetObjectGroupsACRequest) ([]AutocompleteObjectGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteObjectGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetObjectGroupsAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/object-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPiggiesACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetPiggiesACRequest) Query(query string) ApiGetPiggiesACRequest {
	r.query = &query
	return r
}
func (r ApiGetPiggiesACRequest) Limit(limit int32) ApiGetPiggiesACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPiggiesACRequest) Execute() ([]AutocompletePiggy, *_nethttp.Response, error) {
	return r.ApiService.GetPiggiesACExecute(r)
}

/*
 * GetPiggiesAC All piggy banks of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetPiggiesACRequest
 */
func (a *AutocompleteApiService) GetPiggiesAC(ctx _context.Context) ApiGetPiggiesACRequest {
	return ApiGetPiggiesACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompletePiggy
 */
func (a *AutocompleteApiService) GetPiggiesACExecute(r ApiGetPiggiesACRequest) ([]AutocompletePiggy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompletePiggy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetPiggiesAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/piggy-banks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPiggiesBalanceACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetPiggiesBalanceACRequest) Query(query string) ApiGetPiggiesBalanceACRequest {
	r.query = &query
	return r
}
func (r ApiGetPiggiesBalanceACRequest) Limit(limit int32) ApiGetPiggiesBalanceACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPiggiesBalanceACRequest) Execute() ([]AutocompletePiggyBalance, *_nethttp.Response, error) {
	return r.ApiService.GetPiggiesBalanceACExecute(r)
}

/*
 * GetPiggiesBalanceAC All piggy banks of the user returned in a basic auto-complete array complemented with balance information.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetPiggiesBalanceACRequest
 */
func (a *AutocompleteApiService) GetPiggiesBalanceAC(ctx _context.Context) ApiGetPiggiesBalanceACRequest {
	return ApiGetPiggiesBalanceACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompletePiggyBalance
 */
func (a *AutocompleteApiService) GetPiggiesBalanceACExecute(r ApiGetPiggiesBalanceACRequest) ([]AutocompletePiggyBalance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompletePiggyBalance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetPiggiesBalanceAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/piggy-banks-with-balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRuleGroupsACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetRuleGroupsACRequest) Query(query string) ApiGetRuleGroupsACRequest {
	r.query = &query
	return r
}
func (r ApiGetRuleGroupsACRequest) Limit(limit int32) ApiGetRuleGroupsACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetRuleGroupsACRequest) Execute() ([]AutocompleteRuleGroup, *_nethttp.Response, error) {
	return r.ApiService.GetRuleGroupsACExecute(r)
}

/*
 * GetRuleGroupsAC All rule groups of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetRuleGroupsACRequest
 */
func (a *AutocompleteApiService) GetRuleGroupsAC(ctx _context.Context) ApiGetRuleGroupsACRequest {
	return ApiGetRuleGroupsACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteRuleGroup
 */
func (a *AutocompleteApiService) GetRuleGroupsACExecute(r ApiGetRuleGroupsACRequest) ([]AutocompleteRuleGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteRuleGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetRuleGroupsAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/rule-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRulesACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetRulesACRequest) Query(query string) ApiGetRulesACRequest {
	r.query = &query
	return r
}
func (r ApiGetRulesACRequest) Limit(limit int32) ApiGetRulesACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetRulesACRequest) Execute() ([]AutocompleteRule, *_nethttp.Response, error) {
	return r.ApiService.GetRulesACExecute(r)
}

/*
 * GetRulesAC All rules of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetRulesACRequest
 */
func (a *AutocompleteApiService) GetRulesAC(ctx _context.Context) ApiGetRulesACRequest {
	return ApiGetRulesACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteRule
 */
func (a *AutocompleteApiService) GetRulesACExecute(r ApiGetRulesACRequest) ([]AutocompleteRule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetRulesAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetTagACRequest) Query(query string) ApiGetTagACRequest {
	r.query = &query
	return r
}
func (r ApiGetTagACRequest) Limit(limit int32) ApiGetTagACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetTagACRequest) Execute() ([]AutocompleteTag, *_nethttp.Response, error) {
	return r.ApiService.GetTagACExecute(r)
}

/*
 * GetTagAC All tags of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTagACRequest
 */
func (a *AutocompleteApiService) GetTagAC(ctx _context.Context) ApiGetTagACRequest {
	return ApiGetTagACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteTag
 */
func (a *AutocompleteApiService) GetTagACExecute(r ApiGetTagACRequest) ([]AutocompleteTag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteTag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetTagAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionTypesACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetTransactionTypesACRequest) Query(query string) ApiGetTransactionTypesACRequest {
	r.query = &query
	return r
}
func (r ApiGetTransactionTypesACRequest) Limit(limit int32) ApiGetTransactionTypesACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetTransactionTypesACRequest) Execute() ([]AutocompleteTransactionType, *_nethttp.Response, error) {
	return r.ApiService.GetTransactionTypesACExecute(r)
}

/*
 * GetTransactionTypesAC All transaction types returned in a basic auto-complete array. English only.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTransactionTypesACRequest
 */
func (a *AutocompleteApiService) GetTransactionTypesAC(ctx _context.Context) ApiGetTransactionTypesACRequest {
	return ApiGetTransactionTypesACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteTransactionType
 */
func (a *AutocompleteApiService) GetTransactionTypesACExecute(r ApiGetTransactionTypesACRequest) ([]AutocompleteTransactionType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteTransactionType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetTransactionTypesAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/transaction-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionsACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetTransactionsACRequest) Query(query string) ApiGetTransactionsACRequest {
	r.query = &query
	return r
}
func (r ApiGetTransactionsACRequest) Limit(limit int32) ApiGetTransactionsACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetTransactionsACRequest) Execute() ([]AutocompleteTransaction, *_nethttp.Response, error) {
	return r.ApiService.GetTransactionsACExecute(r)
}

/*
 * GetTransactionsAC All transaction descriptions of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTransactionsACRequest
 */
func (a *AutocompleteApiService) GetTransactionsAC(ctx _context.Context) ApiGetTransactionsACRequest {
	return ApiGetTransactionsACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteTransaction
 */
func (a *AutocompleteApiService) GetTransactionsACExecute(r ApiGetTransactionsACRequest) ([]AutocompleteTransaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetTransactionsAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionsIDACRequest struct {
	ctx _context.Context
	ApiService AutocompleteApi
	query *string
	limit *int32
}

func (r ApiGetTransactionsIDACRequest) Query(query string) ApiGetTransactionsIDACRequest {
	r.query = &query
	return r
}
func (r ApiGetTransactionsIDACRequest) Limit(limit int32) ApiGetTransactionsIDACRequest {
	r.limit = &limit
	return r
}

func (r ApiGetTransactionsIDACRequest) Execute() ([]AutocompleteTransactionID, *_nethttp.Response, error) {
	return r.ApiService.GetTransactionsIDACExecute(r)
}

/*
 * GetTransactionsIDAC All transactions, complemented with their ID, of the user returned in a basic auto-complete array.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTransactionsIDACRequest
 */
func (a *AutocompleteApiService) GetTransactionsIDAC(ctx _context.Context) ApiGetTransactionsIDACRequest {
	return ApiGetTransactionsIDACRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []AutocompleteTransactionID
 */
func (a *AutocompleteApiService) GetTransactionsIDACExecute(r ApiGetTransactionsIDACRequest) ([]AutocompleteTransactionID, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AutocompleteTransactionID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutocompleteApiService.GetTransactionsIDAC")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/autocomplete/transactions-with-id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
