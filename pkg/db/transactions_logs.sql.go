// Code generated by sqlc. DO NOT EDIT.
// source: transactions_logs.sql

package db

import (
	"context"
)

const createTransactionsLog = `-- name: CreateTransactionsLog :one
INSERT INTO transactions_logs (
  description,
  category_id
) VALUES (
  $1, $2
)  ON CONFLICT (description) DO UPDATE SET category_id = $2
RETURNING id, description, category_id, created_at, updated_at
`

type CreateTransactionsLogParams struct {
	Description string `json:"description"`
	CategoryID  int32  `json:"category_id"`
}

func (q *Queries) CreateTransactionsLog(ctx context.Context, arg CreateTransactionsLogParams) (TransactionsLog, error) {
	row := q.queryRow(ctx, q.createTransactionsLogStmt, createTransactionsLog, arg.Description, arg.CategoryID)
	var i TransactionsLog
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionsLogByDescription = `-- name: GetTransactionsLogByDescription :one
SELECT id, description, category_id, created_at, updated_at FROM transactions_logs
WHERE description = $1
LIMIT 1
`

func (q *Queries) GetTransactionsLogByDescription(ctx context.Context, description string) (TransactionsLog, error) {
	row := q.queryRow(ctx, q.getTransactionsLogByDescriptionStmt, getTransactionsLogByDescription, description)
	var i TransactionsLog
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
